---
title: Bridging ETH to OP Mainnet with Viem
description: >-
  Learn how to use Viem to transfer ETH between Layer 1 (Ethereum or Sepolia)
  and Layer 2 (OP Mainnet or OP Sepolia).
---

# Bridging ETH to OP Mainnet with Viem

This tutorial explains how you can use [Viem](https://viem.sh) to bridge ETH from L1 (Ethereum or Sepolia) to L2 (OP Mainnet or OP Sepolia).
Viem is a TypeScript interface for Ethereum that provides low-level stateless primitives for interacting with Ethereum.
It offers an easy way to add bridging functionality to your JavaScript-based application.

Behind the scenes, Viem uses the [Standard Bridge](/app-developers/bridging/standard-bridge) contracts to transfer ETH and ERC-20 tokens.
Make sure to check out the [Standard Bridge guide](/app-developers/bridging/standard-bridge) if you want to learn more about how the bridge works under the hood.

## Supported networks

Viem supports any of the [Superchain networks](/superchain/networks).
The OP Stack networks are included in Viem by default.
If you want to use a network that isn't included by default, you can add it to Viem's chain configurations.

## Dependencies

*   [node](https://nodejs.org/en/)
*   [pnpm](https://pnpm.io/installation)

## Create a demo project

You're going to use Viem for this tutorial.
Since Viem is a [Node.js](https://nodejs.org/en/) library, you'll need to create a Node.js project to use it.

<Steps>
  <h3>Make a project folder</h3>

  ```bash
  mkdir bridge-eth
  cd bridge-eth
  ```

  <h3>Initialize the project</h3>

  ```bash
  pnpm init
  ```

  <h3>Install the Viem library</h3>

  ```bash
  pnpm add viem
  ```
</Steps>

<Info>
  Want to create a new wallet for this tutorial?
  If you have [`cast`](https://book.getfoundry.sh/getting-started/installation) installed you can run `cast wallet new` in your terminal to create a new wallet and get the private key.
</Info>

## Get ETH on Sepolia

This tutorial explains how to bridge ETH from Sepolia to OP Sepolia.
You will need to get some ETH on Sepolia to follow along.

<Info>
  You can use [this faucet](https://sepoliafaucet.com) to get ETH on Sepolia.
</Info>

## Add a private key to your environment

You need a private key in order to sign transactions.
Set your private key as an environment variable with the export command.
Make sure this private key corresponds to an address that has ETH on Sepolia.

```bash
export TUTORIAL_PRIVATE_KEY=0x...
```

## Start the Node REPL

You're going to use the Node REPL to interact with Viem.
To start the Node REPL run the following command in your terminal:

```bash
node
```

This will bring up a Node REPL prompt that allows you to run JavaScript code.

## Import dependencies

You need to import some dependencies into your Node REPL session.

<Steps>
<h3>Import Viem and other packages</h3>

```ts
const { createPublicClient, http, createWalletClient, parseEther, formatEther } = require('viem');
const { sepolia, optimismSepolia } = require('viem/chains');
const { privateKeyToAccount } = require('viem/accounts');
const { getL2TransactionHashes, publicActionsL1, publicActionsL2, walletActionsL1, walletActionsL2 } = require('viem/op-stack');
```

<h3>Load private key and set account</h3>

```ts
const PRIVATE_KEY = process.env.TUTORIAL_PRIVATE_KEY;
const account = privateKeyToAccount(PRIVATE_KEY);
```

<h3>Create L1 public client for reading from the Sepolia network</h3>

```ts
const publicClientL1 = createPublicClient({
    chain: sepolia,
    transport: http("https://rpc.ankr.com/eth_sepolia"),
}).extend(publicActionsL1()) 
```


<h3>Create L1 wallet client for sending transactions on Sepolia</h3>

```ts
const walletClientL1 = createWalletClient({
    account,
    chain: sepolia,
    transport: http("https://rpc.ankr.com/eth_sepolia"),
}).extend(walletActionsL1());
```


<h3>Create L2 public client for interacting with OP Sepolia</h3>

```ts
const publicClientL2 = createPublicClient({
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
}).extend(publicActionsL2());
```

<h3>Create L2 wallet client on OP Sepolia</h3>

```ts
const walletClientL2 = createWalletClient({
    account,
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
}).extend(walletActionsL2());
```

</Steps>

## Get ETH on Sepolia

You're going to need some ETH on L1 that you can bridge to L2.
You can get some Sepolia ETH from [this faucet](https://sepoliafaucet.com).

## Deposit ETH

Now that you have some ETH on L1 you can deposit that ETH into the `OptimismPortalProxy` contract. You'll then receive the same number of ETH on L2 in return.

<Tabs items={['depositETH', 'Full Code']}>
  <Tabs.Tab>
    <Steps>
      <h3>Check your wallet balance on L1</h3>

      See how much ETH you have on L1 so you can confirm that the deposit worked later on.

      ```ts
const l1Balance = await publicClientL1.getBalance({ address: account.address });
console.log(`L1 Balance: ${formatEther(l1Balance)} ETH`); 
```

      <Info>
        We used `formatEther` method from `viem` to format the balance to ether.
      </Info>

      <h3>Create the deposit transaction</h3>

      Use `buildDepositTransaction` to build the deposit transaction parameters on the L2.

      ```ts
const depositArgs = await publicClientL2.buildDepositTransaction({
    mint: parseEther("0.0001"),
    to: account.address,
});
```

      <h3>Send the deposit transaction</h3>

      Send the deposit transaction on L1 and log the L1 transaction hash.

      ```ts
const depositHash = await walletClientL1.depositTransaction(depositArgs);
console.log(`Deposit transaction hash on L1: ${depositHash}`);
```

      <h3>Wait for L1 transaction</h3>

      Wait for the L1 transaction to be processed and log the receipt.

      ```ts
const depositReceipt = await publicClientL1.waitForTransactionReceipt({ hash: depositHash });
console.log('L1 transaction confirmed:', depositReceipt);
```

      <h3>Extract the L2 transaction hash</h3>

      Extracts the corresponding L2 transaction hash from the L1 receipt, and logs it.
      This hash represents the deposit transaction on L2.

      ```ts
const [l2Hash] = getL2TransactionHashes(depositReceipt);
console.log(`Corresponding L2 transaction hash: ${l2Hash}`);
```

      <h3>Wait for the L2 transaction to be processed</h3>

      Wait for the L2 transaction to be processed and confirmed and logs the L2 receipt to verify completion.

      ```ts
const l2Receipt = await publicClientL2.waitForTransactionReceipt({
    hash: l2Hash,
}); 
console.log('L2 transaction confirmed:', l2Receipt);
console.log('Deposit completed successfully!');
```
    </Steps>
  </Tabs.Tab>

  <Tabs.Tab>
      ```ts
const { createPublicClient, http, createWalletClient, parseEther, formatEther } = require('viem');
const { sepolia, optimismSepolia } = require('viem/chains');
const { privateKeyToAccount } = require('viem/accounts');
const { getL2TransactionHashes, publicActionsL1, publicActionsL2, walletActionsL1, walletActionsL2 } = require('viem/op-stack');


const PRIVATE_KEY = process.env.TUTORIAL_PRIVATE_KEY;
const account = privateKeyToAccount(PRIVATE_KEY);


const publicClientL1 = createPublicClient({
    chain: sepolia,
    transport: http("https://rpc.ankr.com/eth_sepolia"),
}).extend(publicActionsL1()) 


const walletClientL1 = createWalletClient({
    account,
    chain: sepolia,
    transport: http("https://rpc.ankr.com/eth_sepolia"),
}).extend(walletActionsL1());


const publicClientL2 = createPublicClient({
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
}).extend(publicActionsL2());


const walletClientL2 = createWalletClient({
    account,
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
}).extend(walletActionsL2());

const l1Balance = await publicClientL1.getBalance({ address: account.address });
console.log(`L1 Balance: ${formatEther(l1Balance)} ETH`); 

async function depositETH() {


const depositArgs = await publicClientL2.buildDepositTransaction({
    mint: parseEther("0.0001"),
    to: account.address,
});

const depositHash = await walletClientL1.depositTransaction(depositArgs);
console.log(`Deposit transaction hash on L1: ${depositHash}`);

const depositReceipt = await publicClientL1.waitForTransactionReceipt({ hash: depositHash });
console.log('L1 transaction confirmed:', depositReceipt);

const [l2Hash] = getL2TransactionHashes(depositReceipt);
console.log(`Corresponding L2 transaction hash: ${l2Hash}`);

const l2Receipt = await publicClientL2.waitForTransactionReceipt({
    hash: l2Hash,
}); 
console.log('L2 transaction confirmed:', l2Receipt);
console.log('Deposit completed successfully!');
} 
```
  </Tabs.Tab>
</Tabs>

<Info>
  Using a smart contract wallet?
  As a safety measure, `depositETH` will fail if you try to deposit ETH from a smart contract wallet without specifying a `recipient`.
  Add the `recipient` option to the `depositETH` call to fix this.
</Info>

## Withdraw ETH

You just bridged some ETH from L1 to L2.
Nice!
Now you're going to repeat the process in reverse to bridge some ETH from L2 to L1.

<Tabs items={['withdrawETH', 'Full code']}>
  <Tabs.Tab>
    <Steps>
      <h3>Create the withdrawal transaction</h3>

      Uses `buildWithdrawalTransaction` to create the withdrawal parameters.
      Converts the withdrawal amount to `wei` and specifies the recipient on L1.

      ```ts
//Add the same imports used in DepositETH function
const withdrawalArgs = await publicClientL2.buildWithdrawalTransaction({
value: parseEther('0.0001'),
to: account.address,
});
```

      <h3>Executing the withdrawal</h3>

      This sends the withdrawal transaction on L2, which initiates the withdrawal process on L2 and logs a transaction hash for tracking the withdrawal.

      ```ts
const withdrawalHash = await walletClientL2.initiateWithdrawal(withdrawalArgs);
console.log(`Withdrawal transaction hash on L2: ${withdrawalHash}`);
```

      <h3>Confirming L2 transaction</h3>

      Wait one hour (max) for the L2 Output containing the transaction to be proposed, and log the receipt, which contains important details like the block number etc.

      ```ts
const withdrawalReceipt = await publicClientL2.waitForTransactionReceipt({ hash: withdrawalHash });
console.log('L2 transaction confirmed:', withdrawalReceipt);
```

      <h3>Wait for withdrawal prove</h3>

      Next, is to prove to the bridge on L1 that the withdrawal happened on L2. To achieve that, you first need to wait until the withdrawal is ready to prove.

      ```ts
const { output, withdrawal } = await publicClientL1.waitToProve({
withdrawalReceipt,
targetChain: walletClientL2.chain
});
```

      Build parameters to prove the withdrawal on the L2.

      ```ts
const proveArgs = await publicClientL2.buildProveWithdrawal({
output,
withdrawal,
});
```

      <h3>Prove the withdrawal on the L1</h3>

      Once the withdrawal is ready to be proven, you'll send an L1 transaction to prove that the withdrawal happened on L2.

      ```ts
const proveHash = await walletClientL1.proveWithdrawal(proveArgs);

const proveReceipt = await publicClientL1.waitForTransactionReceipt({ hash: proveHash });
```

      <h3>Wait for withdrawal finalization</h3>

      Before a withdrawal transaction can be finalized, you will need to wait for the finalization period.
      This can only happen after the fault proof period has elapsed. On OP Mainnet, this takes 7 days.

      ```ts
const awaitWithdrawal = await publicClientL1.waitToFinalize({
targetChain: walletClientL2.chain,
withdrawalHash: withdrawal.withdrawalHash,
});
```

      <Info>
        We're currently testing fault proofs on OP Sepolia, so withdrawal times
        reflect Mainnet times.
      </Info>

      <h3>Finalize the withdrawal</h3>

      ```ts
const finalizeHash = await walletClientL1.finalizeWithdrawal({
targetChain: walletClientL2.chain,
withdrawal,
});
```

      <h3>Wait until the withdrawal is finalized</h3>

      ```ts
const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({
hash: finalizeHash
});
```

      <h3>Check the withdrawal status</h3>

      ```ts
const status = await publicClientL1.getWithdrawalStatus({
receipt,
targetChain: walletClientL2.chain
})
console.log('Withdrawal completed successfully!');
```
    </Steps>
  </Tabs.Tab>

  <Tabs.Tab>

  ```ts
//Add the same imports used in DepositETH function
const withdrawalArgs = await publicClientL2.buildWithdrawalTransaction({
value: parseEther('0.0001'),
to: account.address,
});

const withdrawalHash = await walletClientL2.initiateWithdrawal(withdrawalArgs);
console.log(`Withdrawal transaction hash on L2: ${withdrawalHash}`);

const withdrawalReceipt = await publicClientL2.waitForTransactionReceipt({ hash: withdrawalHash });
console.log('L2 transaction confirmed:', withdrawalReceipt);

const { output, withdrawal } = await publicClientL1.waitToProve({
withdrawalReceipt,
targetChain: walletClientL2.chain
});

const proveArgs = await publicClientL2.buildProveWithdrawal({
output,
withdrawal,
});

const proveHash = await walletClientL1.proveWithdrawal(proveArgs);

const proveReceipt = await publicClientL1.waitForTransactionReceipt({ hash: proveHash });

const awaitWithdrawal = await publicClientL1.waitToFinalize({
targetChain: walletClientL2.chain,
withdrawalHash: withdrawal.withdrawalHash,
});

const finalizeHash = await walletClientL1.finalizeWithdrawal({
targetChain: walletClientL2.chain,
withdrawal,
});

const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({
hash: finalizeHash
});

const status = await publicClientL1.getWithdrawalStatus({
receipt,
targetChain: walletClientL2.chain
})
```

  </Tabs.Tab>
</Tabs>

## Important Considerations

<Info>
  *   Challenge period: The 7-day withdrawal challenge Period is crucial for security.
  *   Gas costs: Withdrawals involve transactions on both L2 and L1, each incurring gas fees.
  *   Private Key handling: Use secure key management practices in real applications.
  *   RPC endpoint security: Keep your API key (or any RPC endpoint) secure.
</Info>

## Next Steps

*   Develop a user interface for easier interaction with these bridging functions.
*   Implement robust error handling and retry mechanisms for production use.

You've just deposited and withdrawn ETH using `viem/op-stack`.
You should now be able to write applications that use `viem/op-stack` to transfer ETH between L1 and L2.
Although this tutorial used Sepolia and OP Sepolia, the same process works for Ethereum and OP Mainnet.
