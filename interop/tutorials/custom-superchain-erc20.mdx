---
title: Custom SuperchainERC20 tokens
description: Create SuperchainERC20 tokens with custom behaviors
---

# Custom SuperchainERC20 tokens

<Info>
  The SuperchainERC20 standard is ready for production deployments.
  Please note that the OP Stack interoperability upgrade, required for crosschain messaging, is currently still in active development.
</Info>
## Overview

This guide explains how to upgrade an ERC20 to a [`SuperchainERC20`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SuperchainERC20.sol)  that can then teleport across the Superchain interop cluster quickly and safely using the [`SuperchainTokenBridge`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SuperchainTokenBridge.sol) contract. For more information on how it works, [see the explainer](/interop/superchain-erc20).

To ensure fungibility across chains, `SuperchainERC20` assets must have the same contract address on all chains. This requirement abstracts away the complexity of cross-chain validation. Achieving this requires deterministic deployment methods. There are [many ways to do this](https://github.com/Arachnid/deterministic-deployment-proxy).
Here we will use the [SuperchainERC20 Starter Kit](/app-developers/starter-kit).

<details>
  <summary>About this tutorial</summary>

  **What you'll learn**

  *   How to deploy custom ERC20 tokens across multiple chains at the same address so that they can be bridged with the [`SuperchainTokenBridge`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SuperchainTokenBridge.sol) contract.

  **Prerequisite technical knowledge**

  *   Understanding of smart contract development
  *   Familiarity with blockchain concepts
  *   Familiarity with [standard SuperchainERC20 deployments](/interop/tutorials/deploy-superchain-erc20).

  **Development environment**

  *   Unix-like operating system (Linux, macOS, or WSL for Windows)
  *   Git for version control
</details>

### What you'll do

*   Use the [SuperchainERC20 starter kit](/app-developers/starter-kit) to deploy tokens with your custom code.

## Step by step

<Steps>
  <Step title="General setup">
  Follow the setup steps in the [SuperchainERC20 starter kit](/app-developers/starter-kit#setup), steps 1-4.
  
    1.  Install [Foundry](https://book.getfoundry.sh/getting-started/installation).
  
    2.  Run these commands:
  
        ```sh
        git clone https://github.com/ethereum-optimism/superchainerc20-starter.git
        cd superchainerc20-starter
        pnpm install
        pnpm init:env
        ```
  
    3.  Edit `packages/contracts/configs/deploy-config.toml`'s `[token]` section.
  
        | Parameter      | Meaning                  | Example                  |
        | -------------- | ------------------------ | ------------------------ |
        | owner\_address | Owner of the token       | Your address<sup>1</sup> |
        | name           | Token name               | Quick Transfer Token     |
        | symbol         | Token symbol             | QTT                      |
        | decimals       | Number of decimal places | 18                       |
  
        (1) This should be an address you control (for which you know the private key), which has some ETH on the blockchains in question.
        In the case of Supersim, the default has 10k ETH and you can use it.
        For the devnets, [see here](/interop/tools/devnet#sending-eth-to-the-interop-devnets) to send ETH.
  
    4.  If you change `owner_address`, you need to also set the private key.
        Edit `packages/contracts/.env` to set `DEPLOYER_PRIVATE_KEY` to the private key of an account that has ETH on both devnet blockchains.
  
        ```sh
        DEPLOYER_PRIVATE_KEY= <private key goes here>
        ```
  </Step>

  <Step title="Blockchain-specific setup">
  <Tabs items={['Supersim', 'Devnets']}>
      <Tabs.Tab>
        The [SuperchainERC20 Starter Kit](/app-developers/starter-kit) is already set up for [Supersim](/interop/tools/supersim).
        All you need to do is start it.
  
        ```sh
        ./supersim --interop.autorelay
        ```
      </Tabs.Tab>
  
      <Tabs.Tab>
        The [SuperchainERC20 Starter Kit](/app-developers/starter-kit) is already set up for [Supersim](/interop/tools/supersim).
        If you want to use it with a different set of blockchains, for example the [Devnets](/interop/tools/devnet), follow these steps.
  
        1.  Edit `packages/contracts/foundry.toml` to add the RPC endpoints (add the bottom two rows).
  
            ```toml
            [rpc_endpoints]
            op_chain_a = "http://127.0.0.1:9545"
            op_chain_b = "http://127.0.0.1:9546"
            devnet0 = "https://interop-alpha-0.optimism.io"
            devnet1 = "https://interop-alpha-1.optimism.io"
            ```
  
            You can import most RPC endpoints with this command, but it does not include the Interop devnet.
  
            ```sh
            pnpm contracts:update:rpcs
            ```
  
        2.  Edit `packages/contracts/configs/deploy-config.toml`'s `[deploy-config]` section.
  
            | Parameter        | Meaning                                       | Example                |
            | ---------------- | --------------------------------------------- | ---------------------- |
            | salt<sup>1</sup> | A unique identifier                           | Carthage               |
            | chains           | The chains to deploy the contract<sup>2</sup> | \["devnet0","devnet1"] |
  
            (1) Make sure to specify a previously unused value for the salt, for example your address and a timestamp.
            This is necessary because if the same constructor code is used with the same salt when using the deployment script, it gets the same address, which is a problem if you want a fresh deployment.
  
            (2) These names must correspond to the chain names in the `[rpc_endpoints]` section of `foundry.toml` you updated in the previous step.
      </Tabs.Tab>
    </Tabs>
  </Step>

  <Step title="Create the custom contract">
  The easiest way to do this is to copy and modify the `L2NativeSuperchainERC20.sol` contract.
    Use this code, for example, as `packages/contracts/src/CustomSuperchainToken.sol`.
  
    ```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {SuperchainERC20} from "./SuperchainERC20.sol";
import {Ownable} from "@solady/auth/Ownable.sol";

contract CustomSuperchainToken is SuperchainERC20, Ownable {
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    constructor(address owner_, string memory name_, string memory symbol_, uint8 decimals_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = decimals_;

        _initializeOwner(owner_);
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    function mintTo(address to_, uint256 amount_) external onlyOwner {
        _mint(to_, amount_);
    }

    function faucet() external {
        _mint(msg.sender, 10**_decimals);
    }
}
```
  
    <details>
      <summary>Explanation</summary>
  
      ```solidity
    function faucet() external {
        _mint(msg.sender, 10**_decimals);
    }
```
  
      This function lets users get tokens for themselves.
      This token is for testing purposes, so it is useful for users to get their own tokens to run tests.
    </details>
  </Step>

  <Step title="Deploy the new token">
  1.  Edit `packages/contracts/scripts/SuperchainERC20Deployer.s.sol`:
  
        *   Change line 6 to import the new token.
  
            ```solidity
            import {CustomSuperchainToken} from "../src/CustomSuperchainToken.sol";
            ```
  
        *   Update lines 52-54 to get the `CustomSuperchainToken` initialization code.
  
            ```solidity
            bytes memory initCode = abi.encodePacked(
                  type(CustomSuperchainToken).creationCode, abi.encode(ownerAddr_, name, symbol, uint8(decimals))
            );
            ```
  
        *   Modify line 62 to deploy a `CustomSuperchainToken` contract.
  
            ```solidity
              addr_ = address(new CustomSuperchainToken{salt: _implSalt()}(ownerAddr_, name, symbol, uint8(decimals)));
            ```
  
    2.  Deploy the token contract.
  
    ```sh
    pnpm contracts:deploy:token
    ```
  </Step>

  <Step title="Verify the installation">
  1.  Set `TOKEN_ADDRESS` to the address where the token is deployed.
        You can also play with a previously created token, which is at address [`0xF3Ce0794cB4Ef75A902e07e5D2b75E4D71495ee8`](https://sid.testnet.routescan.io/address/0xF3Ce0794cB4Ef75A902e07e5D2b75E4D71495ee8) on the devnets.
  
        ```sh
        TOKEN_ADDRESS=< Your token address >
        ```
  
    2.  Source the `.env` file to get the private key and the address to which it corresponds.
  
        ```sh
        . packages/contracts/.env
        USER_ADDRESS=`cast wallet address $DEPLOYER_PRIVATE_KEY`
        ```
  
    3.  Set variables for the RPC URLs.
  
        <Tabs items={['Supersim', 'Devnets']}>
          <Tabs.Tab>
            Set these parameters for Supersim.
  
            ```sh
            URL_CHAIN_A=http://127.0.0.1:9545
            URL_CHAIN_B=http://127.0.0.1:9546
            ```
          </Tabs.Tab>
  
          <Tabs.Tab>
            For Devnets, specify in `PRIVATE_KEY` the private key you used for the setup script and then these parameters.
  
            ```sh
            URL_CHAIN_A=https://interop-alpha-0.optimism.io
            URL_CHAIN_B=https://interop-alpha-1.optimism.io
            ```
          </Tabs.Tab>
        </Tabs>
  
    4.  Get your current balance (it should be zero).
  
        ```sh
        cast call --rpc-url $URL_CHAIN_A $TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS | cast --from-wei
        ```
  
    5.  Call the faucet to get a token and check the balance again.
  
        ```sh
        cast send  --private-key $DEPLOYER_PRIVATE_KEY --rpc-url $URL_CHAIN_A $TOKEN_ADDRESS "faucet()"
        cast call --rpc-url $URL_CHAIN_A $TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS | cast --from-wei
        ```
  
    6.  Repeat the same steps on Chain B.
  
        ```sh
        cast call --rpc-url $URL_CHAIN_B $TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS | cast --from-wei
        cast send  --private-key $DEPLOYER_PRIVATE_KEY --rpc-url $URL_CHAIN_B $TOKEN_ADDRESS "faucet()"
        cast call --rpc-url $URL_CHAIN_B $TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS | cast --from-wei
        ```
  </Step>
</Steps>

For more details [see the explainer](/interop/superchain-erc20).

## Next steps

*   Use the [SuperchainERC20 Starter Kit](/app-developers/starter-kit) to deploy your token across the Superchain.
*   If you'd like a guided walkthrough, check out our [tutorial video](https://x.com/i/status/1866095114374045969) instead.
*   Review the [Superchain Interop Explainer](/interop/explainer) for answers to common questions about interoperability.
