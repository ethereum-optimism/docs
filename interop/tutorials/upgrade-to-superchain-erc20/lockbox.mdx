---
title: Lockboxes for permissionless interop
lang: en-US
description: Tutorial on how to take permissionlessly create a lockbox contract to enable Superchain interoperability.
topic: Interoperability
personas: [Developer]
categories: [Tutorial, Interop]
content_type: article
---

<Info>
  The SuperchainERC20 standard is ready for production deployments.
  Please note that the OP Stack interoperability upgrade, required for crosschain messaging, is currently still in active development.
</Info>
## Overview

The lockbox is a smart contract that accepts deposits of the original ERC-20 and issues an equivalent amount of tokens that are Superchain interop compatible.
Users can unwrap their Superchain interop token at any time by returning it to the contract, which burns the Superchain interop tokens and releases the corresponding original ERC-20 from the lockbox.

<details>
  <summary>About this tutorial</summary>

  **What you'll learn**

  * How to permissionlessly create a lockbox contract to enable Superchain interoperability.

  **Prerequisite knowledge**

  * You should already know how to [deploy SuperchainERC20 tokens with custom code](/interop/tutorials/custom-superchain-erc20).
</details>

<Info>
  The code on the documentation site is sample code, *not* production code.
  This means that we ran it, and it works as advertised.
  However, it did not pass through the rigorous audit process that most Optimism code undergoes.
  You're welcome to use it, but if you need it for production purposes you should get it audited first.
</Info>

### What you'll do

Create a lockbox `SuperchainERC20` contract to enable interoperability for an ERC20 contract without permission from the original ERC20 deployer.

## Instructions

Some steps depend on whether you want to deploy on [Supersim](/interop/tools/supersim) or on the [development network](/interop/tools/devnet).

<Steps>
  <Step title="Clone the starter kit">
    ```sh
    npx degit ethereum-optimism/starter-kit-superchain-erc20 lockbox-upgrade
    cd lockbox-upgrade
    ```
  </Step>

  <Step title="Install dependencies">
    ```sh
    pnpm install
    ```
  </Step>

  <Step title="Generate the lockbox contract">
    ```sh
    pnpm run generate-lockbox
    ```
  </Step>

  <Step title="Deploy">
    ```sh
    pnpm foundry script scripts/DeployLockbox.s.sol --broadcast --rpc-url $URL_CHAIN_A --private-key $PRIVATE_KEY
    ```
  </Step>


  <Step title="Install and run Supersim">
    If you are going to use Supersim, [follow these instructions](/app-developers/tutorials/supersim/getting-started/installation) to install and run Supersim.

    <Info>
      Make sure to run Supersim with autorelay on.

      ```sh
      ./supersim --interop.autorelay true
      ```
    </Info>
  </Step>

  <Step title="Setup the ERC-20 token on chain A">
    Download and run the setup script.

    ```sh
    curl https://docs.optimism.io/tutorials/setup-for-erc20-upgrade.sh > setup-for-erc20-upgrade.sh
    chmod +x setup-for-erc20-upgrade.sh
    ./setup-for-erc20-upgrade.sh
    ```

    If you want to deploy to the [development networks](/interop/tools/devnet), provide `setup-for-erc20-upgrade.sh` with the private key of an address with ETH on both devnets.

    ```sh
    ./setup-for-erc20-upgrade.sh <private key>
    ```
  </Step>

  <Step title="Store the addresses">
    Execute the bottom two lines of the setup script output to store the ERC-20 address and the address of the beacon contract.

    ```sh
    BEACON_ADDRESS=0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
    export ERC20_ADDRESS=0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
    ```
  </Step>

  <Step title="Specify environment variables">
    1. Specify these variables, which we use later:

    <Tabs items={['Supersim', 'Devnets']}>
      <Tabs.Tab>
        Set these parameters for Supersim.

        ```sh
        PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
        USER_ADDRESS=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
        URL_CHAIN_A=http://127.0.0.1:9545
        URL_CHAIN_B=http://127.0.0.1:9546
        ```
      </Tabs.Tab>

      <Tabs.Tab>
        For Devnet, specify in `PRIVATE_KEY` the private key you used for the setup script and then these parameters.

        ```sh
        USER_ADDRESS=`cast wallet address --private-key $PRIVATE_KEY`
        URL_CHAIN_A=https://interop-alpha-0.optimism.io
        URL_CHAIN_B=https://interop-alpha-1.optimism.io
        ```
      </Tabs.Tab>
    </Tabs>

    2. Regardless of whether you use Supersim or Devnet, specify these variables.

    ```sh
    INTEROP_BRIDGE=0x4200000000000000000000000000000000000028
    export ERC20_CHAINID=`cast chain-id --rpc-url $URL_CHAIN_A`
    ORIGINAL_TOKEN_NAME=`cast call $ERC20_ADDRESS "name()" --rpc-url $URL_CHAIN_A | cast to-ascii`
    export NEW_TOKEN_NAME="$ORIGINAL_TOKEN_NAME Lockbox"
    ORIGINAL_TOKEN_SYMBOL=`cast call $ERC20_ADDRESS "symbol()" --rpc-url $URL_CHAIN_A | cast to-ascii`
    export NEW_TOKEN_SYMBOL="$ORIGINAL_TOKEN_SYMBOL-L"
    export TOKEN_DECIMALS=`cast call $ERC20_ADDRESS "decimals()" --rpc-url $URL_CHAIN_A | cast to-dec`
    ```
  </Step>

  <Step title="Update the deployment utilities">
  The new `SuperchainERC20` variant is called `LockboxSuperchainERC20`, and it requires different constructor parameters.
    To be able to deploy it, we need to modify some of the deployment utilities.

    1.  Download [the SuperchainERC20 starter kit](/interop/tutorials/deploy-superchain-erc20), and install libraries, etc.

        ```sh
        git clone https://github.com/ethereum-optimism/superchainerc20-starter.git
        cd superchainerc20-starter
        pnpm install
        pnpm init:env
        ```

    2.  Replace `packages/contracts/package.json` with this code:

        ```json
            {
              "name": "@superchainerc20-starter/contracts",
              "main": "index.js",
              "scripts": {
                "deploy:dev": "env-cmd -f .env cross-env-shell 'wait-port http://:8420/ready && forge script scripts/SuperchainERC20Deployer.s.sol --broadcast --private-key $DEPLOYER_PRIVATE_KEY'",
                "deploy:token": "env-cmd -f .env cross-env-shell 'forge script scripts/LockboxDeployer.s.sol --broadcast --private-key $DEPLOYER_PRIVATE_KEY'",
                "update:rpcs": "cd ../.. && ./scripts/fetch-superchain-rpc-urls.sh",
                "install": "forge install",
                "build": "forge build",
                "test": "forge test",
                "init:env": "cp .env.example .env"
              },
              "dependencies": {
                "viem": "^2.21.37"
              }
            }
        ```

    3.  Create a new file, `packages/contracts/scripts/LockboxDeployer.s.sol`:

        ```solidity
          // SPDX-License-Identifier: MIT
          pragma solidity ^0.8.25;

          import {Script, console} from "forge-std/Script.sol";
          import {Vm} from "forge-std/Vm.sol";
          import {LockboxSuperchainERC20} from "../src/LockboxSuperchainERC20.sol";

            contract LockboxDeployer is Script {
              string deployConfig;
              uint256 timestamp;

              constructor() {
                  string memory deployConfigPath = vm.envOr("DEPLOY_CONFIG_PATH", string("/configs/deploy-config.toml"));
                  string memory filePath = string.concat(vm.projectRoot(), deployConfigPath);
                  deployConfig = vm.readFile(filePath);
                  timestamp = vm.unixTime();
              }

              /// @notice Modifier that wraps a function in broadcasting.
              modifier broadcast() {
                  vm.startBroadcast(msg.sender);
                  _;
                  vm.stopBroadcast();
              }

              function setUp() public {}

              function run() public {
                  string[] memory chainsToDeployTo = vm.parseTomlStringArray(deployConfig, ".deploy_config.chains");

                  address deployedAddress;

                  for (uint256 i = 0; i < chainsToDeployTo.length; i++) {
                      string memory chainToDeployTo = chainsToDeployTo[i];

                      console.log("Deploying to chain: ", chainToDeployTo);

                      vm.createSelectFork(chainToDeployTo);
                      address _deployedAddress = deployLockboxSuperchainERC20();
                      deployedAddress = _deployedAddress;
                  }

                  outputDeploymentResult(deployedAddress);
              }

              function deployLockboxSuperchainERC20() public broadcast returns (address addr_) {
                  string memory name = vm.envString("NEW_TOKEN_NAME");
                  string memory symbol = vm.envString("NEW_TOKEN_SYMBOL");
                  uint256 decimals = vm.envUint("TOKEN_DECIMALS");
                  require(decimals <= type(uint8).max, "decimals exceeds uint8 range");
                  address originalTokenAddress = vm.envAddress("ERC20_ADDRESS");
                  uint256 originalChainId = vm.envUint("ERC20_CHAINID");

                  bytes memory initCode = abi.encodePacked(
                      type(LockboxSuperchainERC20).creationCode,
                          abi.encode(name, symbol, uint8(decimals), originalTokenAddress, originalChainId)
                  );
                  address preComputedAddress = vm.computeCreate2Address(_implSalt(), keccak256(initCode));
                  if (preComputedAddress.code.length > 0) {
                      console.log(
                          "There is already a contract at %s", preComputedAddress, "on chain id: ", block.chainid
                      );
                      addr_ = preComputedAddress;
                  } else {
                      addr_ = address(new LockboxSuperchainERC20{salt: _implSalt()}(
                          name, symbol, uint8(decimals), originalTokenAddress, originalChainId));
                      console.log("Deployed LockboxSuperchainERC20 at address: ", addr_, "on chain id: ", block.chainid);
                  }
              }

              function outputDeploymentResult(address deployedAddress) public {
                  console.log("Outputting deployment result");

                  string memory obj = "result";
                  string memory jsonOutput = vm.serializeAddress(obj, "deployedAddress", deployedAddress);

                  vm.writeJson(jsonOutput, "deployment.json");
              }

              /// @notice The CREATE2 salt to be used when deploying the token.
              function _implSalt() internal view returns (bytes32) {
                  string memory salt = vm.parseTomlString(deployConfig, ".deploy_config.salt");
                  return keccak256(abi.encodePacked(salt, timestamp));
              }
            }
          
        ```

        <details>
          <summary>Explanation of the modified functions</summary>

          For the most part, this is the standard `SuperchainERC20Deployer.s.sol` that comes with the SuperchainERC20 starter kit.
          Some functions are modified, as explained below.

            ```solidity
              function deployLockboxSuperchainERC20() public broadcast returns (address addr_) {
                  string memory name = vm.envString("NEW_TOKEN_NAME");
                  string memory symbol = vm.envString("NEW_TOKEN_SYMBOL");
                  uint256 decimals = vm.envUint("TOKEN_DECIMALS");
                  require(decimals <= type(uint8).max, "decimals exceeds uint8 range");
                  address originalTokenAddress = vm.envAddress("ERC20_ADDRESS");
                  uint256 originalChainId = vm.envUint("ERC20_CHAINID");
              }
            ```

          Get the majority of the configuration from the environment.
          Mostly of it is derived from the configuration of the original ERC-20 token.

          Note that there is no `owner` here.
          This `SuperchainERC20` contract does not need an owner, because minting and burning are handled by the users themselves (by locking and unlocking the original tokens).

          ```solidity
                bytes memory initCode = abi.encodePacked(
                    type(LockboxSuperchainERC20).creationCode,
                        abi.encode(name, symbol, uint8(decimals), originalTokenAddress, originalChainId)
                );
                address preComputedAddress = vm.computeCreate2Address(_implSalt(), keccak256(initCode));
                if (preComputedAddress.code.length > 0) {
                    console.log(
                        "There is already a contract at %s", preComputedAddress, "on chain id: ", block.chainid
                    );
                    addr_ = preComputedAddress;
                } else {
                    addr_ = address(new LockboxSuperchainERC20{salt: _implSalt()}(
                        name, symbol, uint8(decimals), originalTokenAddress, originalChainId));
                    console.log("Deployed LockboxSuperchainERC20 at address: ", addr_, "on chain id: ", block.chainid);
                }
              }
          ```

          "Manually" calculate the address that [`CREATE2`](https://www.evm.codes/?fork=cancun#f5) will give us.\
          If there is already a contract there, we have a problem.
          Otherwise, deploy the contract.
        </details>
  </Step>
</Steps>

## Next steps

*   Deploy a [SuperchainERC20](/interop/tutorials/deploy-superchain-erc20) to the Superchain
*   [Learn more about SuperchainERC20](/interop/superchain-erc20)
*   Build a [revolutionary app](/app-developers/get-started) that uses multiple blockchains within the Superchain
