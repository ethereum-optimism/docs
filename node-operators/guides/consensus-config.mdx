---
title: Consensus layer configuration options (op-node)
description: Learn additional configuration and command line options for op-node and the Consensus-Layer.
---



# Consensus layer configuration options (`op-node`)

<Info>
  You can configure your node using the command line options below (also called flags).
  There are also sub-commands, which can be used to invoke functionality such as the console or blockchain import/export.
</Info>

This page lists all configuration options for `op-node`. `op-node` implements most rollup-specific functionality as the Consensus-Layer, similar to an L1 beacon-node.
The following options are from the `--help` in [v1.10.2](https://github.com/ethereum-optimism/optimism/releases/tag/op-node/v1.10.2).

## Recommended configuration

For most node operators, the following configuration provides a good starting point for running op-node.

### Essential flags for a replica node

These are the minimum required flags to run op-node as a replica (non-sequencer):

```bash
op-node \
  --l1=https://ethereum-rpc-endpoint.example.com \
  --l2=http://localhost:8551 \
  --l2.jwt-secret=/path/to/jwt-secret.txt \
  --network=op-mainnet \
  --rpc.addr=0.0.0.0 \
  --rpc.port=9545
```

### Recommended flags for production

For production deployments, add these flags for better reliability and observability:

```bash
op-node \
  --l1=https://ethereum-rpc-endpoint.example.com \
  --l1.beacon=https://ethereum-beacon-endpoint.example.com \
  --l2=http://localhost:8551 \
  --l2.jwt-secret=/path/to/jwt-secret.txt \
  --network=op-mainnet \
  --rpc.addr=0.0.0.0 \
  --rpc.port=9545 \
  --rpc.enable-admin \
  --metrics.enabled \
  --metrics.addr=0.0.0.0 \
  --metrics.port=7300 \
  --pprof.enabled \
  --pprof.addr=0.0.0.0 \
  --pprof.port=6060 \
  --p2p.disable=false \
  --p2p.listen.ip=0.0.0.0 \
  --p2p.listen.tcp=9222 \
  --p2p.listen.udp=9222
```

### Sequencer configuration

If you're running a sequencer node, use these additional flags:

```bash
op-node \
  --l1=https://ethereum-rpc-endpoint.example.com \
  --l1.beacon=https://ethereum-beacon-endpoint.example.com \
  --l2=http://localhost:8551 \
  --l2.jwt-secret=/path/to/jwt-secret.txt \
  --rollup.config=/path/to/rollup.json \
  --rpc.addr=0.0.0.0 \
  --rpc.port=9545 \
  --rpc.enable-admin \
  --sequencer.enabled \
  --sequencer.l1-confs=4 \
  --p2p.sequencer.key=<your-sequencer-private-key>
```

<Warning>
Keep your sequencer private key secure and never commit it to version control.
Use environment variables or secure key management systems in production.
</Warning>

## Important configuration files

When running op-node, you'll work with several important files:

### JWT secret (`--l2.jwt-secret`)

A hex-encoded 32-byte secret used for authenticated communication between op-node (consensus layer) and op-geth (execution layer).
This file must be identical to the one used by op-geth.

Example of generating a JWT secret:
```bash
openssl rand -hex 32 > jwt-secret.txt
```

### Rollup configuration (`--rollup.config`)

The rollup configuration file defines the chain parameters, including:
- Genesis block information
- L1 contract addresses
- Fork activation timestamps
- Block time and sequence window

For standard networks (op-mainnet, base-mainnet, etc.), you can use the `--network` flag instead.
Custom chains require a rollup.json file.

### P2P private key (`--p2p.priv.path`)

The P2P private key file maintains your node's network identity across restarts.
Default location: `opnode_p2p_priv.txt`

This file is automatically generated if it doesn't exist. Keep it persistent to maintain peer connections across restarts.

### Peerstore database (`--p2p.peerstore.path`)

The peerstore persists discovered peer information to speed up P2P bootstrapping after restarts.
Default location: `opnode_peerstore_db`

Set to `memory` to disable persistence (peers must be rediscovered on every restart).

## Configuration options reference

The following sections provide detailed documentation for all available op-node configuration options, organized by functionality.

### L1 and L2 connection settings

Configure how op-node connects to L1 (Ethereum) and L2 (execution layer) endpoints.

#### l1

Address of L1 User JSON-RPC endpoint to use (eth namespace required). The default value is `"http://127.0.0.1:8545"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1="http://127.0.0.1:8545"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_ETH_RPC="http://127.0.0.1:8545"`</Tabs.Tab>
</Tabs>

#### l1.beacon

Address of L1 Beacon-node HTTP endpoint to use.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.beacon=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.beacon="http://127.0.0.1:3500"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_BEACON="http://127.0.0.1:3500"`</Tabs.Tab>
</Tabs>

#### l1.beacon-fallbacks

Addresses of L1 Beacon-API compatible HTTP fallback endpoints. Used to fetch blob sidecars not available at the l1.beacon (e.g. expired blobs).

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.beacon-fallbacks=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.beacon-fallbacks="http://fallback1.example.com,http://fallback2.example.com"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_BEACON_FALLBACKS="http://fallback1.example.com,http://fallback2.example.com"`</Tabs.Tab>
</Tabs>

#### l1.beacon-header

Optional HTTP header to add to all requests to the L1 Beacon endpoint. Format: 'X-Key: Value'

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.beacon-header=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.beacon-header="Authorization: Bearer token"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_BEACON_HEADER="Authorization: Bearer token"`</Tabs.Tab>
</Tabs>

#### l1.beacon.fetch-all-sidecars

If true, all sidecars are fetched and filtered locally. Workaround for buggy Beacon nodes. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.beacon.fetch-all-sidecars=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--l1.beacon.fetch-all-sidecars=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_BEACON=false`</Tabs.Tab>
</Tabs>

#### l1.beacon.ignore

When false, halts `op-node` startup if the healthcheck to the Beacon-node endpoint fails. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.beacon.ignore=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--l1.beacon.ignore=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_BEACON_IGNORE=false`</Tabs.Tab>
</Tabs>

#### l1.cache-size

Cache size for blocks, receipts and transactions. If this flag is set to 0, 3/2 of the sequencing window size is used (usually 2400). The default value of 900 (~3h of L1 blocks) is good for (high-throughput) networks that see frequent safe head increments. On (low-throughput) networks with infrequent safe head increments, it is recommended to set this value to 0, or a value that well covers the typical span between safe head increments. Note that higher values will cause significantly increased memory usage. The default value is `900`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.cache-size=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.cache-size=900`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_CACHE_SIZE=900`</Tabs.Tab>
</Tabs>

#### l1.epoch-poll-interval

Poll interval for retrieving new L1 epoch updates such as safe and finalized block changes. Disabled if 0 or negative. The default value is `6m24s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.epoch-poll-interval=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.epoch-poll-interval=6m24s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_EPOCH_POLL_INTERVAL=6m24s`</Tabs.Tab>
</Tabs>

#### l1.http-poll-interval

Polling interval for latest-block subscription when using an HTTP RPC provider. Ignored for other types of RPC endpoints. The default value is `12s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.http-poll-interval=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.http-poll-interval=12s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_HTTP_POLL_INTERVAL=12s`</Tabs.Tab>
</Tabs>

#### l1.max-concurrency

Maximum number of concurrent RPC requests to make to the L1 RPC provider. The default value is `10`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.max-concurrency=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.max-concurrency=10`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_MAX_CONCURRENCY=10`</Tabs.Tab>
</Tabs>

#### l1.rpc-max-batch-size

Maximum number of RPC requests to bundle, e.g., during L1 blocks receipt fetching. The L1 RPC rate limit counts this as N items, but allows it to burst at once. The default value is `20`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.rpc-max-batch-size=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.rpc-max-batch-size=20`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_RPC_MAX_BATCH_SIZE=20`</Tabs.Tab>
</Tabs>

#### l1.rpc-rate-limit

Optional self-imposed global rate-limit on L1 RPC requests, specified in requests / second. Disabled if set to 0. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.rpc-rate-limit=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.rpc-rate-limit=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_RPC_RATE_LIMIT=0`</Tabs.Tab>
</Tabs>

#### l1.rpckind

The kind of RPC provider, used to inform optimal transactions receipts fetching, and thus reduce costs. Valid options: alchemy, quicknode, infura, parity, `nethermind`, debug\_geth, erigon, basic, any, standard. The default value is `standard`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.rpckind=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.rpckind=standard`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_RPC_KIND=standard`</Tabs.Tab>
</Tabs>

<Info>
  For details on additional values, see [RPC Receipts](https://github.com/ethereum-optimism/optimism/blob/844cc20084a2e9716631b4092ce7eca4804a8e0a/op-service/sources/receipts_rpc.go#L239-L322).
</Info>

#### l1.runtime-config-reload-interval

Poll interval for reloading the runtime config, useful when config events are not being picked up. Disabled if 0 or negative. The default value is `10m0s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.runtime-config-reload-interval=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l1.runtime-config-reload-interval=10m0s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_RUNTIME_CONFIG_RELOAD_INTERVAL=10m0s`</Tabs.Tab>
</Tabs>

#### l1.trustrpc

Trust the L1 RPC, sync faster at risk of malicious/buggy RPC providing bad or inconsistent L1 data. The default value is `false`.

<Info>
  If you're running an Erigon Ethereum execution client for your L1 provider you will need to include `--l1.trustrpc`. At the time of writing,
  Erigon doesn't support the `eth_getProof` that we prefer to use to load L1 data for some processing in `op-node`. The trustrpc flag makes it
  use something else that erigon supports, but the `op-node` can't verify for correctness.
</Info>

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l1.trustrpc=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--l1.trustrpc=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L1_TRUST_RPC=false`</Tabs.Tab>
</Tabs>

#### l2

Address of L2 Engine JSON-RPC endpoints to use (engine and eth namespace required). This is referred to as `authrpc` by Geth and Reth.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l2=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l2=http://127.0.0.1:8751`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L2_ENGINE_RPC=http://127.0.0.1:8751`</Tabs.Tab>
</Tabs>

#### l2.engine-rpc-timeout

L2 engine client rpc timeout. The default value is `10s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l2.engine-rpc-timeout=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l2.engine-rpc-timeout=10s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L2_ENGINE_RPC_TIMEOUT=10s`</Tabs.Tab>
</Tabs>

#### l2.jwt-secret

Path to JWT secret key. Keys are 32 bytes, hex encoded in a file. A new key will be generated if left empty.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l2.jwt-secret=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l2.jwt-secret=/path/to/jwt/secret`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L2_ENGINE_AUTH=/path/to/jwt/secret`</Tabs.Tab>
</Tabs>

#### l2.enginekind

The kind of engine client, used to control the behavior of optimism in respect to different types of engine clients. Valid options: `geth`, `reth`, `erigon`. The default value is `geth`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--l2.enginekind=<value>`</Tabs.Tab>
  <Tabs.Tab>`--l2.enginekind=geth`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_L2_ENGINE_KIND=geth`</Tabs.Tab>
</Tabs>

### Network selection and rollup configuration

Configure which OP Stack network to connect to and manage rollup-specific settings.

#### network

Predefined network selection. Available networks: arena-z-mainnet, arena-z-sepolia,
automata-mainnet, base-devnet-0-sepolia-dev-0, base-mainnet, base-sepolia, bob-mainnet,
camp-sepolia, creator-chain-testnet-sepolia, cyber-mainnet, cyber-sepolia,
ethernity-mainnet, ethernity-sepolia, fraxtal-mainnet, funki-mainnet, funki-sepolia,
hashkeychain-mainnet, ink-mainnet, ink-sepolia, lisk-mainnet, lisk-sepolia, lyra-mainnet,
metal-mainnet, metal-sepolia, mint-mainnet, mode-mainnet, mode-sepolia, op-mainnet,
op-sepolia, oplabs-devnet-0-sepolia-dev-0, orderly-mainnet, ozean-sepolia, pivotal-sepolia,
polynomial-mainnet, race-mainnet, race-sepolia, radius_testnet-sepolia, redstone-mainnet,
rehearsal-0-bn-0-rehearsal-0-bn, rehearsal-0-bn-1-rehearsal-0-bn, settlus-mainnet-mainnet,
settlus-sepolia-sepolia, shape-mainnet, shape-sepolia, silent-data-mainnet-mainnet,
snax-mainnet, soneium-mainnet, soneium-minato-sepolia, sseed-mainnet, swan-mainnet,
swell-mainnet, tbn-mainnet, tbn-sepolia, unichain-mainnet, unichain-sepolia,
worldchain-mainnet, worldchain-sepolia, xterio-eth-mainnet, zora-mainnet, zora-sepolia.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--network=<value>`</Tabs.Tab>
  <Tabs.Tab>`--network=op-mainnet`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_NETWORK=op-mainnet`</Tabs.Tab>
</Tabs>

#### rollup.config

Rollup chain parameters.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--rollup.config=<value>`</Tabs.Tab>
  <Tabs.Tab>`--rollup.config=[ConfigValueHere]`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ROLLUP_CONFIG=[ConfigValueHere]`</Tabs.Tab>
</Tabs>

#### rollup.halt

Opt-in option to halt on incompatible protocol version requirements of the given level (major/minor/patch/none), as signaled onchain in L1.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--rollup.halt=<value>`</Tabs.Tab>
  <Tabs.Tab>`--rollup.halt=[HaltOptionHere]`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ROLLUP_HALT=[HaltOptionHere]`</Tabs.Tab>
</Tabs>

#### rollup.l1-chain-config

Path to .json file with the chain configuration for the L1, either in the direct format or genesis.json format (i.e. embedded under the .config property). Not necessary / will be ignored if using Ethereum mainnet or Sepolia as an L1.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--rollup.l1-chain-config=<value>`</Tabs.Tab>
  <Tabs.Tab>`--rollup.l1-chain-config=/path/to/l1-config.json`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ROLLUP_L1_CHAIN_CONFIG=/path/to/l1-config.json`</Tabs.Tab>
</Tabs>

#### rollup.load-protocol-versions

Load protocol versions from the superchain L1 ProtocolVersions contract (if available), and report in logs and metrics. Default is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--rollup.load-protocol-versions=[true|false]`</Tabs.Tab>
  <Tabs.Tab>`--rollup.load-protocol-versions=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ROLLUP_LOAD_PROTOCOL_VERSIONS=false`</Tabs.Tab>
</Tabs>

#### syncmode

Blockchain sync mode. Options are "consensus-layer" or "execution-layer". The default value is `consensus-layer`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--syncmode=<value>`</Tabs.Tab>
  <Tabs.Tab>`--syncmode=consensus-layer`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SYNCMODE=consensus-layer`</Tabs.Tab>
</Tabs>

### Fork overrides

Manually override fork activation timestamps for testing or custom deployments.

#### override.canyon

Manually specify the Canyon fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.canyon=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.canyon=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_CANYON=0`</Tabs.Tab>
</Tabs>

#### override.delta

Manually specify the Delta fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.delta=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.delta=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_DELTA=0`</Tabs.Tab>
</Tabs>

#### override.ecotone

Manually specify the ecotone fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.ecotone=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.ecotone=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_ECOTONE=0`</Tabs.Tab>
</Tabs>

#### override.fjord

Manually specify the fjord fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.fjord=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.fjord=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_FJORD=0`</Tabs.Tab>
</Tabs>

#### override.granite

Manually specify the granite fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.granite=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.granite=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_GRANITE=0`</Tabs.Tab>
</Tabs>

#### override.holocene

Manually specify the holocene fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.holocene=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.holocene=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_HOLOCENE=0`</Tabs.Tab>
</Tabs>

#### override.isthmus

Manually specify the isthmus fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.isthmus=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.isthmus=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_ISTHMUS=0`</Tabs.Tab>
</Tabs>

#### override.interop

Manually specify the Interop fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.interop=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.interop=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_INTEROP=0`</Tabs.Tab>
</Tabs>

#### override.jovian

Manually specify the Jovian fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.jovian=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.jovian=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_JOVIAN=0`</Tabs.Tab>
</Tabs>

#### override.pectrablobschedule

Manually specify the PectraBlobSchedule fork timestamp, overriding the bundled setting. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--override.pectrablobschedule=<value>`</Tabs.Tab>
  <Tabs.Tab>`--override.pectrablobschedule=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_OVERRIDE_PECTRABLOBSCHEDULE=0`</Tabs.Tab>
</Tabs>

### Logging configuration

Control log output format, level, and color.

#### log.color

Color the log output if in terminal mode. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--log.color=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--log.color=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_LOG_COLOR=false`</Tabs.Tab>
</Tabs>

#### log.format

Format the log output. Supported formats: 'text', 'terminal', 'logfmt', 'json', 'json-pretty'. The default value is `text`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--log.format=<value>`</Tabs.Tab>
  <Tabs.Tab>`--log.format=text`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_LOG_FORMAT=text`</Tabs.Tab>
</Tabs>

#### log.level

The lowest log level that will be output. The default value is `info`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--log.level=<value>`</Tabs.Tab>
  <Tabs.Tab>`--log.level=info`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_LOG_LEVEL=info`</Tabs.Tab>
</Tabs>

#### log.pid

Show pid in the log. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--log.pid=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--log.pid=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_LOG_PID=false`</Tabs.Tab>
</Tabs>

### Logging and RPC

Configure RPC API endpoints and admin functionality.

#### rpc.addr

RPC listening address. Default is `"0.0.0.0"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--rpc.addr=<value>`</Tabs.Tab>
  <Tabs.Tab>`--rpc.addr=0.0.0.0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_RPC_ADDR=0.0.0.0`</Tabs.Tab>
</Tabs>

#### rpc.admin-state

File path used to persist state changes made via the admin API so they persist across restarts. Disabled if not set.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--rpc.admin-state=<value>`</Tabs.Tab>
  <Tabs.Tab>`--rpc.admin-state=[FilePathHere]`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_RPC_ADMIN_STATE=[FilePathHere]`</Tabs.Tab>
</Tabs>

#### rpc.enable-admin

Enable the admin API (experimental). Default is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--rpc.enable-admin=[true|false]`</Tabs.Tab>
  <Tabs.Tab>`--rpc.enable-admin=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_RPC_ENABLE_ADMIN=false`</Tabs.Tab>
</Tabs>

#### rpc.port

RPC listening port. Default is `9545`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--rpc.port=<value>`</Tabs.Tab>
  <Tabs.Tab>`--rpc.port=9545`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_RPC_PORT=9545`</Tabs.Tab>
</Tabs>

### Metrics and profiling

Enable observability through metrics and performance profiling.

#### metrics.addr

Metrics listening address. The default value is `"0.0.0.0"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--metrics.addr=<value>`</Tabs.Tab>
  <Tabs.Tab>`--metrics.addr="0.0.0.0"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_METRICS_ADDR="0.0.0.0"`</Tabs.Tab>
</Tabs>

#### metrics.enabled

Enable the metrics server. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--metrics.enabled=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--metrics.enabled=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_METRICS_ENABLED=false`</Tabs.Tab>
</Tabs>

#### metrics.port

Metrics listening port. The default value is `7300`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--metrics.port=<value>`</Tabs.Tab>
  <Tabs.Tab>`--metrics.port=7300`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_METRICS_PORT=7300`</Tabs.Tab>
</Tabs>

#### pprof.addr

pprof listening address. Default is `"0.0.0.0"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--pprof.addr=<value>`</Tabs.Tab>
  <Tabs.Tab>`--pprof.addr=0.0.0.0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_PPROF_ADDR=0.0.0.0`</Tabs.Tab>
</Tabs>

#### pprof.enabled

Enable the pprof server. Default is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--pprof.enabled=[true|false]`</Tabs.Tab>
  <Tabs.Tab>`--pprof.enabled=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_PPROF_ENABLED=false`</Tabs.Tab>
</Tabs>

#### pprof.path

pprof file path. If it is a directory, the path is \{dir}/\{profileType}.prof

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--pprof.path=<path>`</Tabs.Tab>
  <Tabs.Tab>`--pprof.path={dir}/{profileType}.prof`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_PPROF_PATH={dir}/{profileType}.prof`</Tabs.Tab>
</Tabs>

#### pprof.port

pprof listening port. Default is `6060`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--pprof.port=<value>`</Tabs.Tab>
  <Tabs.Tab>`--pprof.port=6060`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_PPROF_PORT=6060`</Tabs.Tab>
</Tabs>

#### pprof.type

pprof profile type. One of cpu, heap, goroutine, threadcreate, block, mutex, allocs

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--pprof.type=<value>`</Tabs.Tab>
  <Tabs.Tab>`--pprof.type=cpu`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_PPROF_TYPE=cpu`</Tabs.Tab>
</Tabs>

### P2P networking

Configure peer-to-peer networking, discovery, and connection management.

#### p2p.advertise.ip

The IP address to advertise in Discv5, put into the ENR of the node. This may also be a hostname/domain name to resolve to an IP.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.advertise.ip=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.advertise.ip=YourIPAddressOrHostnameHere`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_ADVERTISE_IP=YourIPAddressOrHostnameHere`</Tabs.Tab>
</Tabs>

#### p2p.advertise.tcp

The TCP port to advertise in Discv5, put into the ENR of the node. Set to p2p.listen.tcp value if 0. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.advertise.tcp=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.advertise.tcp=3456`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_ADVERTISE_TCP=3456`</Tabs.Tab>
</Tabs>

#### p2p.advertise.udp

The UDP port to advertise in Discv5 as a fallback if not determined by Discv5, put into the ENR of the node. Set to p2p.listen.udp value if 0. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.advertise.udp=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.advertise.udp=3457`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_ADVERTISE_UDP=3457`</Tabs.Tab>
</Tabs>

#### p2p.ban.duration

The duration that peers are banned for. The default value is `1h0m0s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.ban.duration=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.ban.duration=1h0m0s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PEER_BANNING_DURATION=1h0m0s`</Tabs.Tab>
</Tabs>

#### p2p.ban.peers

Enables peer banning. The default value is `true`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.ban.peers=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.ban.peers=true`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PEER_BANNING=true`</Tabs.Tab>
</Tabs>

#### p2p.ban.threshold

The minimum score below which peers are disconnected and banned. The default value is `-100`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.ban.threshold=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.ban.threshold=-100`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PEER_BANNING_THRESHOLD=-100`</Tabs.Tab>
</Tabs>

#### p2p.bootnodes

Comma-separated base64-format ENR list. Bootnodes to start discovering other node records from.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.bootnodes=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.bootnodes=YourBootnodesListHere`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_BOOTNODES=YourBootnodesListHere`</Tabs.Tab>
</Tabs>

#### p2p.disable

Completely disable the P2P stack. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.disable=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.disable=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_DISABLE=false`</Tabs.Tab>
</Tabs>

#### p2p.discovery.path

Enables persistent storage of discovered ENRs in a database to recover from a restart without bootstrapping the discovery process again. Set to 'memory' to never persist the peerstore. The default value is `opnode_discovery_db`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.discovery.path=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.discovery.path=opnode_discovery_db`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_DISCOVERY_PATH=opnode_discovery_db`</Tabs.Tab>
</Tabs>

#### p2p.gossip.timestamp.threshold

Threshold for rejecting gossip messages with payload timestamps older than this duration. The default value is `1m0s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.gossip.timestamp.threshold=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.gossip.timestamp.threshold=1m0s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_GOSSIP_TIMESTAMP_THRESHOLD=1m0s`</Tabs.Tab>
</Tabs>

#### p2p.listen.ip

Specifies the IP to bind LibP2P and Discv5 to. The default value is `0.0.0.0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.listen.ip=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.listen.ip=0.0.0.0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_LISTEN_IP=0.0.0.0`</Tabs.Tab>
</Tabs>

#### p2p.listen.tcp

Defines the TCP port to bind LibP2P to. Any available system port if set to 0. The default value is `9222`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.listen.tcp=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.listen.tcp=9222`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_LISTEN_TCP_PORT=9222`</Tabs.Tab>
</Tabs>

#### p2p.listen.udp

Sets the UDP port to bind Discv5 to. It will be the same as the TCP port if left at 0. The default value is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.listen.udp=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.listen.udp=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_LISTEN_UDP_PORT=0`</Tabs.Tab>
</Tabs>

#### p2p.nat

Enables NAT traversal with PMP/UPNP devices to learn external IP. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.nat=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.nat=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_NAT=false`</Tabs.Tab>
</Tabs>

#### p2p.netrestrict

Specifies a comma-separated list of CIDR masks. P2P will only try to connect on these networks.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.netrestrict=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.netrestrict=`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_NETRESTRICT=`</Tabs.Tab>
</Tabs>

#### p2p.no-discovery

Disables Discv5 (node discovery). The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.no-discovery=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.no-discovery=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_NO_DISCOVERY=false`</Tabs.Tab>
</Tabs>

#### p2p.peers.grace

Determines the grace period to keep a newly connected peer around, if it is not misbehaving. The default value is `30s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.peers.grace=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.peers.grace=30s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PEERS_GRACE=30s`</Tabs.Tab>
</Tabs>

#### p2p.peers.hi

Sets the high-tide peer count. The node starts pruning peer connections slowly after reaching this number. The default value is `30`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.peers.hi=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.peers.hi=30`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PEERS_HI=30`</Tabs.Tab>
</Tabs>

#### p2p.peers.lo

Determines the low-tide peer count. The node actively searches for new peer connections if below this amount. The default value is `20`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.peers.lo=<number>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.peers.lo=20`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PEERS_LO=20`</Tabs.Tab>
</Tabs>

#### p2p.peerstore.path

Specifies the Peerstore database location. Persisted peerstores help recover peers after restarts. Set to 'memory' to never persist the peerstore. Warning: a copy of the priv network key of the local peer will be persisted here. The default value is `"opnode_peerstore_db"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.peerstore.path=<path>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.peerstore.path=opnode_peerstore_db`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PEERSTORE_PATH=opnode_peerstore_db`</Tabs.Tab>
</Tabs>

#### p2p.priv.path

Defines the file path for reading the hex-encoded 32-byte private key for the peer ID. Created if not already exists. Important for maintaining the same network identity after restarting. The default value is `"opnode_p2p_priv.txt"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.priv.path=<file-path>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.priv.path=opnode_p2p_priv.txt`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PRIV_PATH=opnode_p2p_priv.txt`</Tabs.Tab>
</Tabs>

#### p2p.scoring

Sets the peer scoring strategy for the P2P stack. Options include 'none' or 'light'. The default value is `"light"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.scoring=<strategy>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.scoring=light`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_PEER_SCORING=light`</Tabs.Tab>
</Tabs>

#### p2p.sequencer.key

Hex-encoded private key for signing off on p2p application messages as sequencer.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.sequencer.key=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.sequencer.key=[YourKeyHere]`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_SEQUENCER_KEY=[YourKeyHere]`</Tabs.Tab>
</Tabs>

#### p2p.static

Comma-separated multiaddr-format(an unsigned address, containing: IP, TCP port, [PeerID](/operators/node-operators/json-rpc#opp2p_self)) peer list. Static connections to make and
maintain, these peers will be regarded as trusted. Addresses of the local peer
are ignored. Duplicate/Alternative addresses for the same peer all apply, but
only a single connection per peer is maintained.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.static=<value>`</Tabs.Tab>
  <Tabs.Tab>`--p2p.static=/ip4/127.0.0.1/tcp/9222/p2p/16Uiu2HAm2y6DXp6THWHCyquczNUh8gVAm4spo6hjP3Ns1dGRiAdE`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_STATIC=/ip4/127.0.0.1/tcp/9222/p2p/16Uiu2HAm2y6DXp6THWHCyquczNUh8gVAm4spo6hjP3Ns1dGRiAdE`</Tabs.Tab>
</Tabs>

#### p2p.sync.onlyreqtostatic

Restricts `RequestL2Range` sync requests to static peers only. Useful for enforcing trusted peer sync. When enabled, non-static peers are skipped during sync. Default is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.sync.onlyreqtostatic=[true|false]`</Tabs.Tab>
  <Tabs.Tab>`--p2p.sync.onlyreqtostatic=true`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_SYNC_ONLYREQTOSTATIC=true`</Tabs.Tab>
</Tabs>

#### p2p.sync.req-resp

Enables P2P req-resp alternative sync method, on both server and client side. Default is `true`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--p2p.sync.req-resp=[true|false]`</Tabs.Tab>
  <Tabs.Tab>`--p2p.sync.req-resp=true`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_P2P_SYNC_REQ_RESP=true`</Tabs.Tab>
</Tabs>

### Sequencer options

Configuration for running op-node as a sequencer.

#### sequencer.enabled

Enable sequencing of new L2 blocks. A separate batch submitter has to be deployed to publish the data for verifiers. Default is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--sequencer.enabled=[true|false]`</Tabs.Tab>
  <Tabs.Tab>`--sequencer.enabled=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SEQUENCER_ENABLED=false`</Tabs.Tab>
</Tabs>

#### sequencer.l1-confs

Number of L1 blocks to keep distance from the L1 head as a sequencer for picking an L1 origin. Default is `4`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--sequencer.l1-confs=<value>`</Tabs.Tab>
  <Tabs.Tab>`--sequencer.l1-confs=4`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SEQUENCER_L1_CONFS=4`</Tabs.Tab>
</Tabs>

<Warning>
The maximum value for `sequencer.l1-confs` cannot exceed the sequencer drift, currently set to 30 minutes (1800 seconds or 150 blocks). Setting a value higher than this limit will prevent the sequencer from producing blocks within the sequence window.
</Warning>

#### sequencer.max-safe-lag

Maximum number of L2 blocks for restricting the distance between L2 safe and unsafe. Disabled if 0. Default is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--sequencer.max-safe-lag=<value>`</Tabs.Tab>
  <Tabs.Tab>`--sequencer.max-safe-lag=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SEQUENCER_MAX_SAFE_LAG=0`</Tabs.Tab>
</Tabs>

#### sequencer.recover

Forces the sequencer to strictly prepare the next L1 origin and create empty L2 blocks. Default is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--sequencer.recover=[true|false]`</Tabs.Tab>
  <Tabs.Tab>`--sequencer.recover=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SEQUENCER_RECOVER=false`</Tabs.Tab>
</Tabs>

#### sequencer.stopped

Initialize the sequencer in a stopped state. The sequencer can be started using the admin\_startSequencer RPC. Default is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--sequencer.stopped=[true|false]`</Tabs.Tab>
  <Tabs.Tab>`--sequencer.stopped=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SEQUENCER_STOPPED=false`</Tabs.Tab>
</Tabs>

### Verifier options

Configuration for running op-node as a verifier (replica node).

#### verifier.l1-confs

Number of L1 blocks to keep distance from the L1 head before deriving L2 data from. Reorgs are supported, but may be slow to perform. Default is `0`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--verifier.l1-confs=<value>`</Tabs.Tab>
  <Tabs.Tab>`--verifier.l1-confs=0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_VERIFIER_L1_CONFS=0`</Tabs.Tab>
</Tabs>

<Info>
While `verifier.l1-confs` has no strict limit, it's recommended to keep this value within 12-13 minutes (typically 10-20 blocks) for optimal performance. Exceeding this range may impact the verifier's data processing efficiency.
</Info>

### Conductor mode

Options for running op-node in conductor mode (for conductor-enabled chains).

#### conductor.enabled

Enable the conductor service. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--conductor.enabled=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--conductor.enabled=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_CONDUCTOR_ENABLED=false`</Tabs.Tab>
</Tabs>

#### conductor.rpc

Conductor service rpc endpoint. The default value is `http://127.0.0.1:8547`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--conductor.rpc=<value>`</Tabs.Tab>
  <Tabs.Tab>`--conductor.rpc=http://127.0.0.1:8547`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_CONDUCTOR_RPC=http://127.0.0.1:8547`</Tabs.Tab>
</Tabs>

#### conductor.rpc-timeout

Conductor service rpc timeout. The default value is `1s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--conductor.rpc-timeout=<value>`</Tabs.Tab>
  <Tabs.Tab>`--conductor.rpc-timeout=1s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_CONDUCTOR_RPC_TIMEOUT=1s`</Tabs.Tab>
</Tabs>

### Database and state persistence

Configure persistent storage for node state and snapshot data.

#### safedb.path

File path used to persist safe head update data. Disabled if not set.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--safedb.path=<value>`</Tabs.Tab>
  <Tabs.Tab>`--safedb.path=/db`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SAFEDB_PATH=/db`</Tabs.Tab>
</Tabs>

#### snapshotlog.file

Path to the snapshot log file.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--snapshotlog.file=<value>`</Tabs.Tab>
  <Tabs.Tab>`--snapshotlog.file=[FilePathHere]`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SNAPSHOT_LOG=[FilePathHere]`</Tabs.Tab>
</Tabs>

### Signer configuration

Options for configuring an external signer for P2P messages.

#### signer.address

Address the signer is signing requests for.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--signer.address=<value>`</Tabs.Tab>
  <Tabs.Tab>`--signer.address=0x1234...`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SIGNER_ADDRESS=0x1234...`</Tabs.Tab>
</Tabs>

#### signer.endpoint

Signer endpoint the client will connect to.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--signer.endpoint=<value>`</Tabs.Tab>
  <Tabs.Tab>`--signer.endpoint=https://signer.example.com`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SIGNER_ENDPOINT=https://signer.example.com`</Tabs.Tab>
</Tabs>

#### signer.header

Headers to pass to the remote signer. Format `key=value`. Value can contain any character allowed in a HTTP header. When using env vars, split with commas. When using flags one key value pair per flag.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--signer.header=<value>`</Tabs.Tab>
  <Tabs.Tab>`--signer.header="Authorization: Bearer token"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SIGNER_HEADER="Authorization: Bearer token"`</Tabs.Tab>
</Tabs>

#### signer.tls.ca

TLS ca cert path. The default value is `"tls/ca.crt"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--signer.tls.ca=<value>`</Tabs.Tab>
  <Tabs.Tab>`--signer.tls.ca="tls/ca.crt"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SIGNER_TLS_CA="tls/ca.crt"`</Tabs.Tab>
</Tabs>

#### signer.tls.cert

TLS cert path. The default value is `"tls/tls.crt"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--signer.tls.cert=<value>`</Tabs.Tab>
  <Tabs.Tab>`--signer.tls.cert="tls/tls.crt"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SIGNER_TLS_CERT="tls/tls.crt"`</Tabs.Tab>
</Tabs>

#### signer.tls.enabled

Enable or disable TLS client authentication for the signer. The default value is `true`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--signer.tls.enabled=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--signer.tls.enabled=true`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SIGNER_TLS_ENABLED=true`</Tabs.Tab>
</Tabs>

#### signer.tls.key

TLS key path. The default value is `"tls/tls.key"`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--signer.tls.key=<value>`</Tabs.Tab>
  <Tabs.Tab>`--signer.tls.key="tls/tls.key"`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_SIGNER_TLS_KEY="tls/tls.key"`</Tabs.Tab>
</Tabs>

### Alt-DA (Experimental)

<Warning>
Alt-DA Mode is a Beta feature of the MIT licensed OP Stack. While it has received initial review from core contributors, it is still undergoing testing, and may have bugs or other issues.
</Warning>

Configuration options for Alternative Data Availability mode.

#### altda.enabled

Enable Alt-DA mode. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--altda.enabled=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--altda.enabled=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ALTDA_ENABLED=false`</Tabs.Tab>
</Tabs>

#### altda.da-server

HTTP address of a DA Server.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--altda.da-server=<value>`</Tabs.Tab>
  <Tabs.Tab>`--altda.da-server=http://da-server.example.com`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ALTDA_DA_SERVER=http://da-server.example.com`</Tabs.Tab>
</Tabs>

#### altda.da-service

Use DA service type where commitments are generated by Alt-DA server. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--altda.da-service=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--altda.da-service=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ALTDA_DA_SERVICE=false`</Tabs.Tab>
</Tabs>

#### altda.get-timeout

Timeout for get requests. 0 means no timeout. The default value is `0s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--altda.get-timeout=<value>`</Tabs.Tab>
  <Tabs.Tab>`--altda.get-timeout=0s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ALTDA_GET_TIMEOUT=0s`</Tabs.Tab>
</Tabs>

#### altda.max-concurrent-da-requests

Maximum number of concurrent requests to the DA server. The default value is `1`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--altda.max-concurrent-da-requests=<value>`</Tabs.Tab>
  <Tabs.Tab>`--altda.max-concurrent-da-requests=1`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ALTDA_MAX_CONCURRENT_DA_REQUESTS=1`</Tabs.Tab>
</Tabs>

#### altda.put-timeout

Timeout for put requests. 0 means no timeout. The default value is `0s`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--altda.put-timeout=<value>`</Tabs.Tab>
  <Tabs.Tab>`--altda.put-timeout=0s`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ALTDA_PUT_TIMEOUT=0s`</Tabs.Tab>
</Tabs>

#### altda.verify-on-read

Verify input data matches the commitments from the DA storage service. The default value is `true`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--altda.verify-on-read=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--altda.verify-on-read=true`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_ALTDA_VERIFY_ON_READ=true`</Tabs.Tab>
</Tabs>

### Interop (Super Experimental)

<Warning>
Interop is a highly experimental feature. Use with caution in production environments.
</Warning>

Configuration options for OP Stack interop networks.

#### interop.dependency-set

Dependency-set configuration, point at JSON file.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--interop.dependency-set=<value>`</Tabs.Tab>
  <Tabs.Tab>`--interop.dependency-set=/path/to/dependency-set.json`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_INTEROP_DEPENDENCY_SET=/path/to/dependency-set.json`</Tabs.Tab>
</Tabs>

#### interop.jwt-secret

Interop RPC server authentication. Path to JWT secret key. Keys are 32 bytes, hex encoded in a file. A new key will be generated if the file is empty. Applies only to Interop-enabled networks.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--interop.jwt-secret=<value>`</Tabs.Tab>
  <Tabs.Tab>`--interop.jwt-secret=/path/to/interop-jwt-secret.txt`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_INTEROP_JWT_SECRET=/path/to/interop-jwt-secret.txt`</Tabs.Tab>
</Tabs>

#### interop.rpc.addr

Interop Websocket-only RPC listening address, for supervisor service to manage syncing of the op-node. Applies only to Interop-enabled networks. Optional, disabled if left empty. Do not enable if you do not run a supervisor service.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--interop.rpc.addr=<value>`</Tabs.Tab>
  <Tabs.Tab>`--interop.rpc.addr=0.0.0.0`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_INTEROP_RPC_ADDR=0.0.0.0`</Tabs.Tab>
</Tabs>

#### interop.rpc.port

Interop RPC listening port, to serve supervisor syncing. Applies only to Interop-enabled networks. The default value is `9645`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--interop.rpc.port=<value>`</Tabs.Tab>
  <Tabs.Tab>`--interop.rpc.port=9645`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_INTEROP_RPC_PORT=9645`</Tabs.Tab>
</Tabs>

### Experimental and miscellaneous

Additional experimental features and utility flags.

#### experimental.sequencer-api

Enables experimental test sequencer RPC functionality. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--experimental.sequencer-api=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--experimental.sequencer-api=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_EXPERIMENTAL_SEQUENCER_API=false`</Tabs.Tab>
</Tabs>

#### fetch-withdrawal-root-from-state

Read withdrawal_storage_root (aka message passer storage root) from state trie (via execution layer) instead of the block header. Restores pre-Isthmus behavior, requires an archive EL client. The default value is `false`.

<Tabs items={['Syntax', 'Example', 'Environment Variable']}>
  <Tabs.Tab>`--fetch-withdrawal-root-from-state=<boolean>`</Tabs.Tab>
  <Tabs.Tab>`--fetch-withdrawal-root-from-state=false`</Tabs.Tab>
  <Tabs.Tab>`OP_NODE_FETCH_WITHDRAWAL_ROOT_FROM_STATE=false`</Tabs.Tab>
</Tabs>

## General options

Help and version information.

### --help, -h

Show help. The default value is `false`.

<Tabs items={['Syntax', 'Example']}>
  <Tabs.Tab>`--help` OR `-h`</Tabs.Tab>
  <Tabs.Tab>`--help`</Tabs.Tab>
</Tabs>

### --version, -v

<Info>
  Nodes built from source do not output the correct version numbers that are reported on
  the GitHub release page.
</Info>

Print the version. The default value is `false`.

<Tabs items={['Syntax', 'Example']}>
  <Tabs.Tab>`--version` OR `-v`</Tabs.Tab>
  <Tabs.Tab>`--version`</Tabs.Tab>
</Tabs>

### Node log levels

Node log levels determine the verbosity of log messages, allowing operators to filter messages based on importance and detail. The log levels for the `op-node` (used in Optimism)
are as follows:

1.  Silent (0): No log messages are displayed. This level is rarely used as it provides
    no feedback on the node's status.

2.  Error (1): Only error messages are displayed. Use this level to focus on critical
    issues that need immediate attention.

3.  Warn (2): Displays error messages and warnings. This level helps to identify
    potential problems that might not be immediately critical but require attention.

4.  Info (3): Displays error messages, warnings, and normal activity logs. This is the
    default level and provides a balanced view of the node's operations without being too
    verbose.

5.  Debug (4): All info-level messages plus additional debugging information. Use this
    level when troubleshooting issues or developing the node software.

6.  Detail (5): The most verbose level, including detailed debugging information and
    low-level system operations. This level generates a large amount of log data and is
    typically used only for in-depth troubleshooting.

To set the log level, use the `--log.level` flag when running the `op-node` command. For
example, to set the log level to debug:

```bash
op-node --log.level=debug
```

By adjusting the log level, operators can control the amount and type of information that
gets logged, helping to manage log data volume and focus on relevant details during
different operational scenarios.
