---
title: Oracles
lang: en-US
description: Learn about different oracles and how you can use them to access offchain data onchain as well as random number generation.
tags: ["devops-tooling", "performance-tooling", "eng-devx"]
---

import { Callout } from 'nextra/components'

# Oracles

<Callout type="default">
  This page includes providers that meet specific [inclusion criteria](#inclusion-criteria), as outlined below.
</Callout>

This reference guide lists different Oracles you can use when building on Metal Layer 2. [Oracles](https://ethereum.org/en/developers/docs/oracles/) provide offchain data onchain. This allows code running on a blockchain to access a wide variety of information.
For example, a [stablecoin](https://ethereum.org/en/stablecoins/) that accepts ETH as collateral needs to know the ETH/USD exchange rate:

*   How many stablecoins can we give a user for a given amount of ETH?
*   Do we need to liquidate any deposits because they are under collateralized?

## Security and decentralization

Different oracles have different security assumptions and different levels of decentralization.
Usually they are either run by the organization that produces the information, or have a mechanism to reward entities that provide accurate information and penalize those that provide incorrect information.

## Types of oracles

There are two types of oracles:

1.  **Push oracles** are updated continuously and always have up to date information available onchain.

2.  **Pull oracles** are only updated when information is requested by a contract.
    Pull oracles are themselves divided into two types:
    1.  Double-transaction oracles, which require two transactions.
        The first transaction is the request for information, which usually causes the oracle to emit an event that triggers some offchain mechanism to provide the answer (through its own transaction).
        The second transaction actually reads onchain the result from the oracle and uses it.
    2.  Single-transaction oracles, which only require one transaction. The way this works is that the transaction that requests the information includes a callback (address and the call data to provide it).
        When the oracle is updated (which also happens through a transaction, but one that is not sent by the user), the oracle uses the callback to inform a contract of the result.

## Random number generation (RGN)

Random number generation in blockchain applications ensures that smart contracts can access unbiased random values. This is essential for certain use cases like generative NFTs, gaming, commit & reveal schemes and more. Various approaches include using a trusted third party, blockhash-based methods, Verifiable Random Functions (VRF), quantum random numbers to name a few. Each method has trade-offs between simplicity, security, and trust assumptions, allowing developers to select the most suitable option for their use case.

## List of Oracles

### API3

The [API3 Market](https://market.api3.org/metal) provides access to 200+ price feeds on [Metal L2 Mainnet](https://market.api3.org/metal). The price feeds operate as a native push oracle and can be activated instantly via the Market UI.


### Chronicle

The first Oracle on Ethereum, Chronicle's decentralized Oracle network was originally built within MakerDAO for the development of DAI and is now available to builders on OP Mainnet and the Superchain.

*   **Data Feeds**: Builders can choose from 65+ data feeds, including crypto assets, yield rates, and RWAs. Chronicle's data is sourced via custom-built data models, only utilizing Tier 1 Primary Sources, such as the markets where tokens are actively traded, including Coinbase, Binance, Uniswap, and Curve.
*   **Transparency & Integrity**: Chronicle's Oracle network is fully transparent and verifiable. Via [The Chronicle](https://chroniclelabs.org/dashboard/oracle/DAI/USD?blockchain=OPT\&txn=0x53e60e6e79eb938e5ca3ca6c56b0795e003dd6b3a17cfd810ca5042b3d33b680\&contract=0x104916d38828DA8B83a88A1775Aa058e1F0B1647), the data supply chain for any Oracle can be viewed in real-time and historically, including data sources and the identity of all Validators/Signers. Users can cryptographically challenge the integrity of every Oracle update using the 'verify' feature. Data is independently sourced by a [community of Validators](https://chroniclelabs.org/validators), including Gitcoin, Etherscan, Infura, DeFi Saver, and MakerDAO.
*   **Gas Efficiency:** Pioneering the Schnorr-based Oracle architecture, Chronicle's Oracles use 60-80% less gas per update than other Oracle providers. This lowest cost per update allows Push Oracle updates to be made more regularly, ensuring more accurate and granular data reporting.

Every Oracle implementation is customized to fit your needs. Implement one of our existing data models or contact Chronicle to develop custom Oracle data feeds via [Discord](https://discord.gg/CjgvJ9EspJ) or [Email](mailto:gm@chroniclelabs.org). Developers can dive deeper into Chronicle Protocol's architecture and unique design choices [via the docs](https://docs.chroniclelabs.org/).


## Inclusion Criteria

Developer teams who want to feature products/tools on this page must meet the following criteria:

1.  **ongoing partnership** with Metal L2 whether formal agreement, RPGF, RFP, collaborated on specific initiatives, etc.;
2.  **established user base** and Metal L2 ecosystem engagement such as governance participation, homegrown TG or Discord participation, etc.; and
3.  **actively maintained developer tool** that aligns with Metal L2's commitment to a magical developer experience (e.g., easy-to-use, easy-to-integrate, great DevX, highly-rated by community, etc.)


## Next steps

*   Looking for other developer tools? See [developer tools overview](/builders/tools/overview) to explore more options!
