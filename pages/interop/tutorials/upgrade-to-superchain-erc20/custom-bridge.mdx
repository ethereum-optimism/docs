---
title: Custom interoperability bridges
lang: en-US
description: Tutorial on how to create a custom interoperability bridge. The example is a bridge when the addresses of the ERC20 contracts are not the same.
topic: Interoperability
personas: [Developer]
categories: [Tutorial, Interop]
content_type: article
---

import { Steps, Callout, Tabs } from 'nextra/components'

<Callout>
  The SuperchainERC20 standard is ready for production deployments.
  Please note that the OP Stack interoperability upgrade, required for crosschain messaging, is currently still in active development.
</Callout>

# Custom interoperability bridges

## Overview

Sometimes the address of an ERC20 contract is not available on a different chain.
This means that the [standard bridge](/interop/superchain-erc20) is not an option. 
However, if the original ERC20 contract is behind a proxy (so we can add [ERC7802](https://eips.ethereum.org/EIPS/eip-7802) support), we can still use interop bridging.


<details>
  <summary>About this tutorial</summary>

  **What you'll learn**

  *   How to use [interop message passing](/interop/tutorials/message-passing) to create a custom bridge.

  **Prerequisite knowledge**

  *   How to [deploy SuperchainERC20 tokens with custom code](/stack/interop/tutorials/custom-superchain-erc20).
  *   How to [transfer interop messages](/interop/tutorials/message-passing).


</details>

<Callout type="warning">
  The code on the documentation site is sample code, *not* production code.
  This means that we ran it, and it works as advertised.
  However, it did not pass through the rigorous audit process that most Optimism code undergoes.
  You're welcome to use it, but if you need it for production purposes you should get it audited first.
</Callout>

{/* 

I put this warning here, when we don't have it on most pages, because this tutorial
has code that is a lot more likely to be used in production. It doesn't just
show what is possible, it does the exact job needed.

*/}

### What you'll do

Create a lockbox `SuperchainERC20` contract to enable interoperability for an ERC20 contract without permission from the original ERC20 deployer.

## Instructions

Some steps depend on whether you want to deploy on [supersim](/stack/interop/tools/supersim) or on the [development network](/stack/interop/tools/devnet).

<Steps>
  ### Install and run Supersim

  If you are going to use Supersim, [follow these instructions](/app-developers/tutorials/supersim/getting-started/installation) to install and run Supersim.

  <Callout>
    Make sure to run Supersim with autorelay on.

    ```sh
    ./supersim --interop.autorelay true
    ```
  </Callout>

  ### Setup the ERC-20 token on chain A

  Download and run the setup script.

  ```sh
  curl https://docs.optimism.io/tutorials/setup-for-erc20-upgrade.sh > setup-for-erc20-upgrade.sh
  chmod +x setup-for-erc20-upgrade.sh
  ./setup-for-erc20-upgrade.sh
  ```

  If you want to deploy to the [development networks](/stack/interop/tools/devnet), provide `setup-for-erc20-upgrade.sh` with the private key of an address with ETH on both devnets.

  ```sh
  ./setup-for-erc20-upgrade.sh <private key>
  ```

  ### Store the addresses

  Execute the bottom two lines of the setup script output to store the ERC-20 address and the address of the beacon contract.

  ```sh
  BEACON_ADDRESS=0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
  export ERC20_ADDRESS=0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
  ```

  ### Specify environment variables

  1.  Specify these variables, which we use later:

      <Tabs items={['Supersim', 'Devnets']}>
        <Tabs.Tab>
          Set these parameters for Supersim.

          ```sh
          PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
          USER_ADDRESS=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
          URL_CHAIN_A=http://127.0.0.1:9545
          URL_CHAIN_B=http://127.0.0.1:9546
          ```
        </Tabs.Tab>

        <Tabs.Tab>
          For Devnet, specify in `PRIVATE_KEY` the private key you used for the setup script and then these parameters.

          ```sh
          USER_ADDRESS=`cast wallet address --private-key $PRIVATE_KEY`
          URL_CHAIN_A=https://interop-alpha-0.optimism.io
          URL_CHAIN_B=https://interop-alpha-1.optimism.io
          ```
        </Tabs.Tab>
      </Tabs>

  2.  Regardless of whether you use Supersim or Devnet, specify these variables.

      ```sh
      INTEROP_BRIDGE=0x4200000000000000000000000000000000000028
      export ERC20_CHAINID=`cast chain-id --rpc-url $URL_CHAIN_A`
      ORIGINAL_TOKEN_NAME=`cast call $ERC20_ADDRESS "name()" --rpc-url $URL_CHAIN_A | cast to-ascii`
      export NEW_TOKEN_NAME="$ORIGINAL_TOKEN_NAME Lockbox"
      ORIGINAL_TOKEN_SYMBOL=`cast call $ERC20_ADDRESS "symbol()" --rpc-url $URL_CHAIN_A | cast to-ascii`
      export NEW_TOKEN_SYMBOL="$ORIGINAL_TOKEN_SYMBOL-L"
      export TOKEN_DECIMALS=`cast call $ERC20_ADDRESS "decimals()" --rpc-url $URL_CHAIN_A | cast to-dec`
      ```

  ### Update the deployment utilities

  The new `SuperchainERC20` variant is called `LockboxSuperchainERC20`, and it requires different constructor parameters.
  To be able to deploy it, we need to modify some of the deployment utilities.

  1.  Download [the SuperchainERC20 starter kit](/stack/interop/tutorials/deploy-superchain-erc20), and install libraries, etc.

      ```sh
      git clone https://github.com/ethereum-optimism/superchainerc20-starter.git
      cd superchainerc20-starter
      pnpm install
      pnpm init:env
      ```

  2.  Replace `packages/contracts/package.json` with this code:

      ```json filename="packages/contracts/package.json"
      {
        "name": "@superchainerc20-starter/contracts",
        "main": "index.js",
        "scripts": {
          "deploy:dev": "env-cmd -f .env cross-env-shell 'wait-port http://:8420/ready && forge script scripts/SuperchainERC20Deployer.s.sol --broadcast --private-key $DEPLOYER_PRIVATE_KEY'",
          "deploy:token": "env-cmd -f .env cross-env-shell 'forge script scripts/LockboxDeployer.s.sol --broadcast --private-key $DEPLOYER_PRIVATE_KEY'",
          "update:rpcs": "cd ../.. && ./scripts/fetch-superchain-rpc-urls.sh",
          "install": "forge install",
          "build": "forge build",
          "test": "forge test",
          "init:env": "cp .env.example .env"
        },
        "dependencies": {
          "viem": "^2.21.37"
        }
      }      
      ```

  3.  Create a new file, `packages/contracts/scripts/LockboxDeployer.s.sol`:

      ```solidity filename="packages/contracts/scripts/LockboxDeployer.s.sol" file=<rootDir>/public/tutorials/LockboxDeployer.s.sol hash=534b543709be173d87508a53322d8c59
      ```

      <details>
        <summary>Explanation of the modified functions</summary>

        For the most part, this is the standard `SuperchainERC20Deployer.s.sol` that comes with the SuperchainERC20 starter kit.
        Some functions are modified, as explained below.

        ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L46-L52 hash=302d02c3895f109e5e64d265b0473e6a
        ```

        Get the majority of the configuration from the environment.
        Mostly of it is derived from the configuration of the original ERC-20 token.

        Note that there is no `owner` here.
        This `SuperchainERC20` contract does not need an owner, because minting and burning are handled by the users themselves (by locking and unlocking the original tokens).

        ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L54-L69 hash=c45855080dc554cece35ed87e2d68f68
        ```

        "Manually" calculate the address that [`CREATE2`](https://www.evm.codes/?fork=cancun#f5) will give us.\
        If there is already a contract there, we have a problem.
        Otherwise, deploy `LockboxSuperchainERC20`.

        ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L80-L84 hash=5d1f71b16a6f02d52a79b1a9e7588f87
        ```

        I modified this salt function to include a timestamp (obtained using `vm.unixTime()` in the constructor).
        This is not necessary, but I consider it a developer experience improvement.
        During development you redeploy slightly modified code a lot of times.
        It is easier if you don't need to manually change the salt every time.

        <Callout type="warning">
          Remove this before deploying to production.
          Otherwise, as new blockchains join the Interop cluster, you may not be able to deploy your contract at the same address.
        </Callout>
      </details>

  ### Create and deploy the new contract

  1.  Create this file in `packages/contracts/src/LockboxSuperchainERC20.sol`:

      ```solidity filename="packages/contracts/src/LockboxSuperchainERC20.sol" file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol hash=d326f0e1c26904b844263274914951cf
      ```

      <details>
        <summary>Explanation</summary>

        ```solidity file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol#L11-L12 hash=45d211a19533f9b0dee310743b25459f
        ```

        The lockbox contract needs to know the contract for which it is a lockbox.
        This requires not just the address, but also to know what chain has it.

        ```solidity file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol#L47-L57 hash=20f6aa15d113dcaf992875184173cb47
        ```

        Users call this function to transfer original tokens to the contract and mint themselves an equivalent number of lockbox tokens.
        This function has several tests to make sure it can be called.

        *   Check the chain ID.
            Locking and redeeming tokens can only be done on the original token's chain.
        *   Use [`transferFrom`](https://ethereum.org/en/developers/tutorials/erc20-annotated-code/#transferFrom) to transfer the tokens to ourselves.
            This call typically reverts when it fails, but it can also return `false`.
            In that case, we revert.
            There are two reasons it may fail.
            *   The user (in this case, the `LockboxSuperchainERC20` contract) does not have [the allowance](https://ethereum.org/en/developers/tutorials/erc20-annotated-code/#_approve) to spend that amount of tokens from the original owner (`msg.sender`).
            *   The original owner (`msg.sender`) does not have enough tokens to transfer.

        If the tests are successful, mint the requested amount for `msg.sender`.

        ```solidity file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol#L59-L67 hash=2e63a9cd1ac1114c3fb2110e28b60924
        ```

        Users call this function to redeem their existing lockbox tokens and replace them with the original tokens.
        It also has multiple tests.

        *   Again, check chain ID.
        *   Try to `_burn` the amount of lockbox tokens.
            [The solady `_burn` function](https://github.com/Vectorized/solady/blob/main/src/tokens/ERC20.sol#L539-L542), the one we inherit from `SuperchainERC20`, reverts if the user does not have enough tokens to burn.
        *   Transfer the amount of the original ERC-20 redeemed to
            the caller.
            This should never fail, because lockbox ERC-20 tokens are supposed to always be backed by an equal number of the original tokens.
            However, if it does fail for some reason, revert.
      </details>

  2.  Actually deploy the contract.

      <Tabs items={['Supersim', 'Devnets']}>
        <Tabs.Tab>
          ```sh
          pnpm contracts:deploy:token
          ```
        </Tabs.Tab>

        <Tabs.Tab>
          To deploy to the [development networks](/stack/interop/tools/devnet), follow the steps [in the tutorial](/stack/interop/tutorials/deploy-superchain-erc20#prepare-for-deployment) before you deploy the contract.

          Then, update `packages/contracts/.env` and deploy the token.

          ```sh
          echo DEPLOYER_PRIVATE_KEY=$PRIVATE_KEY > packages/contracts/.env
          pnpm contracts:deploy:token
          ```
        </Tabs.Tab>
      </Tabs>

  3.  Get the new token address and store it in an environment variable.

      ```sh
      NEW_TOKEN_ADDRESS=`cat packages/contracts/broadcast/multi/LockboxDeployer.s.sol-latest/run.json | awk '/contractAddress/ {print $2}' | head -1 | sed 's/[",]//g'`
      ```

  ### Verification

  1.  Check that the user has a single token of the original ERC-20.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      ```

  2.  Lock a quarter token in the lockbox ERC-20 contract.
      To do this we first need to give the lockbox ERC-20 contract an allowance and then call it.

      ```sh
      QUARTER_TOKEN=`echo 0.25 | cast to-wei`
      cast send $ERC20_ADDRESS "approve(address,uint256)" $NEW_TOKEN_ADDRESS $QUARTER_TOKEN --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_A
      cast send $NEW_TOKEN_ADDRESS "lockAndMint(uint256)" $QUARTER_TOKEN --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_A
      ```

  3.  See the balances of the user, both original and lockbox, and the balance of the lockbox contract itself.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $ERC20_ADDRESS "balanceOf(address)" $NEW_TOKEN_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      ```

  4.  Transfer 0.1 token to chain B.

      ```sh
      TENTH_TOKEN=`echo 0.1 | cast to-wei`
      cast send $INTEROP_BRIDGE --rpc-url $URL_CHAIN_A --private-key $PRIVATE_KEY "sendERC20(address,address,uint256,uint256)" $NEW_TOKEN_ADDRESS $USER_ADDRESS $TENTH_TOKEN `cast chain-id --rpc-url $URL_CHAIN_B`
      ```

  5.  See the user's balances on both chains.

      ```sh
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_B | cast from-wei
      ```

  6.  Specify the configuration for another user.

      <Tabs items={['Supersim', 'Devnets']}>
        <Tabs.Tab>
          ```sh
          USER_ADDRESS_2=0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC
          PRIVATE_KEY_2=0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a
          ```
        </Tabs.Tab>

        <Tabs.Tab>
          Specify the private key (`PRIVATE_KEY_2`) and user address (`USER_ADDRESS_2`) of another user that has ETH on both devnets.
        </Tabs.Tab>
      </Tabs>

  7.  Transfer new tokens to the new user (on chain B) and see that they were actually transferred.

      ```sh
      cast send $NEW_TOKEN_ADDRESS "transfer(address,uint256)" $USER_ADDRESS_2 $TENTH_TOKEN --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_B
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_B | cast from-wei
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS_2 --rpc-url $URL_CHAIN_B | cast from-wei      
      ```

  8.  As the new user, transfer tokens back to chain A and redeem them.

      ```sh
      cast send $INTEROP_BRIDGE --rpc-url $URL_CHAIN_B --private-key $PRIVATE_KEY_2 "sendERC20(address,address,uint256,uint256)" $NEW_TOKEN_ADDRESS $USER_ADDRESS_2 $TENTH_TOKEN `cast chain-id --rpc-url $URL_CHAIN_A`
      cast send $NEW_TOKEN_ADDRESS --rpc-url $URL_CHAIN_A --private-key $PRIVATE_KEY_2 "redeemAndBurn(uint256)" $TENTH_TOKEN
      ```

  9.  See that the second user does not have any more of the new tokens, but does have the original token.

      ```sh
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS_2 --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS_2 --rpc-url $URL_CHAIN_A | cast from-wei      
      ```
</Steps>

## Next steps

*   Deploy a [SuperchainERC20](/stack/interop/tutorials/deploy-superchain-erc20) to the Superchain
*   [Learn more about SuperchainERC20](/stack/interop/superchain-erc20)
*   Build a [revolutionary app](/app-developers/get-started) that uses multiple blockchains within the Superchain




