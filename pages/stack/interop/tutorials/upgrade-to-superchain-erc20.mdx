---
title: Upgrading ERC20 to SuperchainERC20
lang: en-US
description: What to do if you already have an ERC-20 token, and now you need to support Interop.
---

import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'

<Callout>
  The SuperchainERC20 standard is ready for production deployments.
  Please note that the OP Stack interoperability upgrade, required for crosschain messaging, is currently still in active development.
</Callout>

# Upgrading ERC20 to SuperchainERC20

## Overview

This guide explains how to upgrade an ERC20 to a [`SuperchainERC20`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SuperchainERC20.sol) that can teleport across the [Superchain interop cluster](../explainer#superchain-interop-cluster) using the [`SuperchainTokenBridge`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SuperchainTokenBridge.sol) contract. For more information on how it works, [see the explainer](/stack/interop/superchain-erc20).

<details>
  <summary>About this tutorial</summary>

  **What you'll learn**

  *   How to upgrade an ERC-20 token to enable Superchain interoperability under various conditions.

  **Prerequisite knowlege**

  *   You should already know how to [deploy SuperchainERC20 tokens with custom code](./custom-superchain-erc20).
</details>

<Callout type="warning">
  The code on the documentation site is sample code, *not* production code.
  This means that we ran it, and it works as advertised.
  However, it did not pass through the rigorous audit process that most Optimism code undergoes.
  You're welcome to use it, but if you need it for production purposes you should get it audited first.
</Callout>

{/* 

I put this warning here, when we don't have it on most pages, because this tutorial
has, IMHO, code that is a lot more likely to be used in production. It doesn't just
show what is possible, it does the exact job needed.

*/}

### What you'll do

*   Upgrade an existing ERC-20 that uses [the proxy pattern](https://docs.openzeppelin.com/upgrades-plugins/proxies) to comply with interop requirements (with the proper authority).
*   Create a "lockbox" SuperchainERC20 contract to permissionlessly enable interop.

## Setup

These initial setup steps are required for both the [proxy upgrade](#upgrade-a-proxied-contract) and the [lockbox solution](#lockboxes-for-permissionless-interop).

<Steps>
  ### Install and run Supersim

  [Follow these instructions](/app-developers/tutorials/supersim/getting-started/installation) to install and run Supersim.

  <Callout>
    Make sure to run Supersim with autorelay on.

    ```sh
    ./supersim --interop.autorelay true
    ```
  </Callout>

  ### Setup the ERC-20 token on chain A

  Download and run the setup script.

  ```sh
  curl  https://docs.optimism.io/tutorials/setup-for-erc20-upgrade.sh > setup-for-erc20-upgrade.sh
  chmod +x setup-for-erc20-upgrade.sh
  ./setup-for-erc20-upgrade.sh
  ```

  ### Store the addresses

  Execute the bottom two lines of the setup script output to store the ERC-20 address and the address of the beacon contract.

  ```sh
  BEACON_ADDRESS=0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
  export ERC20_ADDRESS=0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
  ```

  ### Specify environment variables

  Specify these variables, which will be useful later.

  ```sh
  PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
  USER_ADDRESS=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
  URL_CHAIN_A=http://127.0.0.1:9545
  URL_CHAIN_B=http://127.0.0.1:9546
  INTEROP_BRIDGE=0x4200000000000000000000000000000000000028
  ```
</Steps>

## Upgrade a proxied contract

There are several requirements for an ERC-20 to use Superchain interop:

*   The ERC-20 contract has to implement [ERC-7802](https://eips.ethereum.org/EIPS/eip-7802) and [ERC-165](https://eips.ethereum.org/EIPS/eip-165).
    We need to modify the ERC-20 implementation for this support, which is the reason this particular technique requires a proxied contract where we control the proxy.
*   The equivalent ERC-20 contracts need to be on the same address on the other chains.
*   The storage layout of the ERC-20 contract needs to be the same as the one of `SuperchainERC20`.

The exact method to get the same address depends on how the proxy contract was initially deployed.
In this case we can see it in the upgrade script.

We need to follow the same steps, from the same address, with the same nonce.
Luckily, we should be able to do it in this case.

<Steps>
  ### Create a Foundry project

  We create a [Foundry](https://book.getfoundry.sh/) project and import the [OpenZeppelin](https://www.openzeppelin.com/solidity-contracts) contracts, which were used for the original ERC-20 and proxy deployment.

  ```sh
  mkdir proxy-upgrade
  cd proxy-upgrade
  forge init
  forge install OpenZeppelin/openzeppelin-contracts
  forge install OpenZeppelin/openzeppelin-contracts-upgradeable
  forge install ethereum-optimism/interop-lib
  ```

  ### Create and run the deployment script

  1.  Create an `script/LabSetup.s.sol` file with this content:

      ```solidity file=<rootDir>/public/tutorials/setup-for-erc20-upgrade.sh#L17-L56 hash=8c54bec9989ae4e1734825d3828ae220 filename="script/LabSetup.s.sol"
      ```

      This is the same deployment script used for the original deployment on chain A.

  2.  Run this command to deploy the same contracts on chain B.

      ```sh
      forge script script/LabSetup.s.sol --rpc-url $URL_CHAIN_B --broadcast --private-key $PRIVATE_KEY --tc LabSetup
      ```

      Scroll up and see the Logs section of the output:

      ```
      == Logs ==
      Token address: 0x5FbDB2315678afecb367f032d93F642f64180aa3
      msg.sender: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
      UpgradeableBeacon: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
      Proxy: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
      ```

      Verify that the proxy address is the same as `$ERC20_ADDRESS`, and that the beacon address is the same as `$BEACON_ADDRESS`.

        <details>
          <summary>What to do when the values are not the same</summary>

          This can happen when the nonce values of `0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266` on chain A and chain B are different.

          You can see the nonce values using these commands:

          ```sh
          cast nonce $USER_ADDRESS --rpc-url $URL_CHAIN_A
          cast nonce $USER_ADDRESS --rpc-url $URL_CHAIN_B
          ```

          The easiest solution is to send transactions to the chain with the lower nonce until the nonces are equal, and then deploy to both chains.

          ```sh
          forge script script/LabSetup.s.sol --rpc-url $URL_CHAIN_A --broadcast --private-key $PRIVATE_KEY --tc LabSetup
          forge script script/LabSetup.s.sol --rpc-url $URL_CHAIN_B --broadcast --private-key $PRIVATE_KEY --tc LabSetup
          ```

          If you do this, remember to update `$ERC20_ADDRESS` and `$BEACON_ADDRESS`.
        </details>

  <Callout>
    Note that if we couldn't redeploy on chain A (because the ERC-20 was already in use, not just a test system) and the nonce on chain B was already higher than what it had been on chain A when the proxy contract was deployed, it would have been impossible to create on chain B an ERC-20 account with the same address as the ERC-20 on chain A.

    There are two alternative solutions:

    *   [Lockboxes](#lockboxes-for-permissionless-interop), which require users to exchange their tokens for tokens that can go through interop.
    *   Creating a custom bridge using the [L2toL2CrossDomainMessenger](./message-passing) to facilitate cross-chain mint/burns that does not require a deterministic address across chains but does require the token issuer to manage a token registry per chain.
  </Callout>

  ### Deploy ERC-7802 contracts

  We need to replace the ERC-20 contracts with contracts that:

  *   Support [ERC-7802](https://eips.ethereum.org/EIPS/eip-7802) and [ERC-165](https://eips.ethereum.org/EIPS/eip-165).
  *   Have the same storage layout as the ERC-20 contracts they replace.

  <Callout>
    These contracts do *not* need to be deployed to the same address.
    The address that needs to be the same is not the address of the ERC-20 contract itself, but of the proxy.
  </Callout>

  1.  Create a file, `src/InteropToken.sol`:

      ```solidity file=<rootDir>/public/tutorials/InteropToken.sol hash=007791836635608fdeb9c70c1b368f25 filename="src/InteropToken.sol"
      ```

        <details>
          <summary>Detailed explanation</summary>

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L1-L5 hash=36b9b9d0fb1ff680dc0eaa1c48b7c56b
          ```

          Most of the code is identical to the original `MyToken`.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L6-L7 hash=f06f3bd72be73dbd754008da7dd00d48        
          ```

          These are the imports needed for ERC-7802 support.
          We need `IERC165` for documentation purposes, and `IERC7802` for the ERC-7802 events.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L9 hash=ca402292e7551621669ef1a59b85d7ce     
          ```

          We also implement [ERC-165](https://eips.ethereum.org/EIPS/eip-165), but we don't need to import anything from there.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L10-L14 hash=37e9b49f50a8b70971ce5d0112bd934e     
          ```

          This function is identical to the one in `MyToken`.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L16-L36 hash=448a7e21e094b3fd961f2b8ee15bc6c7     
          ```

          Standard [ERC-7802](https://eips.ethereum.org/EIPS/eip-7802) behavior.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L38-L42 hash=abb2093e9681984f25afa6f9d8b237a3     
          ```

          Standard [ERC-165](https://eips.ethereum.org/EIPS/eip-165) behavior.
        </details>

        <Callout>
          Copying the original ERC-20 token code with minimal differences is one method to keep the storage layout identical.
          Alternatively, if you want to use a different contract, such as `SuperchainERC20`, you can modify the storage layout to match the old one using [the Solidity docs](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html).
        </Callout>

  2.  Deploy this contract on both chains, and store the addresses (which may or may not be the same).

      ```sh
      ERC7802_A=`forge create InteropToken --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_A --broadcast | awk '/Deployed to:/ {print $3}'`
      ERC7802_B=`forge create InteropToken --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_B --broadcast | awk '/Deployed to:/ {print $3}'`
      ```

  ### Update proxies

  Notify the beacon contracts of the new implementation contracts.

  ```sh
  cast send $BEACON_ADDRESS --private-key $PRIVATE_KEY "upgradeTo(address)" $ERC7802_A --rpc-url $URL_CHAIN_A
  cast send $BEACON_ADDRESS --private-key $PRIVATE_KEY "upgradeTo(address)" $ERC7802_B --rpc-url $URL_CHAIN_B  
  ```
</Steps>

<details>
  <summary>Sanity check</summary>

  1.  See your balance on chain A.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      ```

  2.  See your balance on chain B.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_B | cast from-wei
      ```

  3.  Transfer 0.1 token.

      ```sh
      AMOUNT=`echo 0.1 | cast to-wei`
      cast send $INTEROP_BRIDGE --rpc-url $URL_CHAIN_A --private-key $PRIVATE_KEY "sendERC20(address,address,uint256,uint256)" $ERC20_ADDRESS $USER_ADDRESS $AMOUNT 902
      ```

  4.  See the new balances. The A chain should have 0.9 tokens, and the B chain should have 0.1 tokens.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_B | cast from-wei
      ```
</details>

## Lockboxes for permissionless interop

There are many cases in which the previous technique is not usable:

*   The original ERC-20 contract was not deployed behind a proxy, so there is no way to make it implement [ERC-7802](https://eips.ethereum.org/EIPS/eip-7802).
*   The original ERC-20 contract was a proxy, but it was deployed either directly or using the [`CREATE`](https://www.evm.codes/?fork=cancun#f0) opcode and that nonce value has already been used by that address on one of the chains you need to interoperate with.
*   The private key for the address that originally deployed the ERC-20 contract is not available. This could happen, for example, because the organization that deployed the ERC-20 contract does not wish to cooperate.

For those cases there is an alternative solution, the lockbox.
The lockbox is smart contract that accepts deposits of the original ERC-20 and issues an equivalent amount of tokens that are Superchain interop compatible.
Users can unwrap their Superchain interop token at any time by returning it to the contract, which burns the Superchain interop tokens and releases the corresponding original ERC-20 from the lockbox.

<Steps>
  ### Setup environment variables

  We need a few more environment variables to make token information available for the new deployment.

  ```sh
  export ERC20_ADDRESS
  export ERC20_CHAINID=`cast chain-id --rpc-url $URL_CHAIN_A`
  ORIGINAL_TOKEN_NAME=`cast call $ERC20_ADDRESS "name()" --rpc-url $URL_CHAIN_A | cast to-ascii`
  export NEW_TOKEN_NAME="$ORIGINAL_TOKEN_NAME Lockbox"
  ORIGINAL_TOKEN_SYMBOL=`cast call $ERC20_ADDRESS "symbol()" --rpc-url $URL_CHAIN_A | cast to-ascii`
  export NEW_TOKEN_SYMBOL="$ORIGINAL_TOKEN_SYMBOL-L"
  export TOKEN_DECIMALS=`cast call $ERC20_ADDRESS "decimals()" --rpc-url $URL_CHAIN_A | cast to-dec`
  ```

  ### Update the deployment utilities

  The new `SuperchainERC20` variant is called `LockboxSuperchainERC20`, and it requires different constructor parameters.
  To be able to deploy it, we need to modify some of the deployment utilities.

  1.  Download [the SuperchainERC20 starter kit](./deploy-superchain-erc20), and install libraries, etc.

      ```sh
      git clone https://github.com/ethereum-optimism/superchainerc20-starter.git
      cd superchainerc20-starter
      pnpm install
      pnpm init:env
      ```

  2.  Replace `packages/contracts/package.json` with this code:

      ```json filename="packages/contracts/package.json"
      {
        "name": "@superchainerc20-starter/contracts",
        "main": "index.js",
        "scripts": {
          "deploy:dev": "env-cmd -f .env cross-env-shell 'wait-port http://:8420/ready && forge script scripts/SuperchainERC20Deployer.s.sol --broadcast --private-key $DEPLOYER_PRIVATE_KEY'",
          "deploy:token": "env-cmd -f .env cross-env-shell 'forge script scripts/LockboxDeployer.s.sol --broadcast --private-key $DEPLOYER_PRIVATE_KEY'",
          "update:rpcs": "cd ../.. && ./scripts/fetch-superchain-rpc-urls.sh",
          "install": "forge install",
          "build": "forge build",
          "test": "forge test",
          "init:env": "cp .env.example .env"
        },
        "dependencies": {
          "viem": "^2.21.37"
        }
      }      
      ```

  3.  Create a new file, `packages/contracts/scripts/LockboxDeployer.s.sol`:

      ```solidity filename="packages/contracts/scripts/LockboxDeployer.s.sol" file=<rootDir>/public/tutorials/LockboxDeployer.s.sol hash=534b543709be173d87508a53322d8c59
      ```

        <details>
          <summary>Explanation of the modified functions</summary>

          For the most part, this is the standard `SuperchainERC20Deployer.s.sol` that comes with the SuperchainERC20 starter kit.
          Some functions are modified, as explained below.

          ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L46-L52 hash=302d02c3895f109e5e64d265b0473e6a
          ```

          Get the majority of the configuration from the environment.
          Mostly of it is derived from the configuration of the original ERC-20 token.

          Note that there is no `owner` here.
          This `SuperchainERC20` contract does not need an owner, because minting and burning are handled by the users themselves (by locking and unlocking the original tokens).

          ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L54-L69 hash=c45855080dc554cece35ed87e2d68f68
          ```

          "Manually" calculate the address that [`CREATE2`](https://www.evm.codes/?fork=cancun#f5) will give us.\
          If there is already a contract there, we have a problem.
          Otherwise, deploy `LockboxSuperchainERC20`.

          ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L80-L84 hash=5d1f71b16a6f02d52a79b1a9e7588f87
          ```

          I modified this salt function to include a timestamp (obtained using `vm.unixTime()` in the constructor).
          This is not necessary, but I consider it a developer experience improvement.
          During development you redeploy slightly modified code a lot of times.
          It is easier if you don't need to manually change the salt every time.

          <Callout type="warning">
            Remove this before deploying to production.
            Otherwise, as new blockchains join the Interop cluster, you may not be able to deploy your contract at the same address.
          </Callout>
        </details>

  ### Create and deploy the new contract

  1.  Create this file in `packages/contracts/src/LockboxSuperchainERC20.sol`:

      ```solidity filename="packages/contracts/src/LockboxSuperchainERC20.sol" file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol hash=d326f0e1c26904b844263274914951cf
      ```

        <details>
          <summary>Explanation</summary>

          ```solidity file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol#L11-L12 hash=45d211a19533f9b0dee310743b25459f
          ```

          The lockbox contract needs to know the contract for which it is a lockbox.
          This requires not just the address, but also to know what chain has it.

          ```solidity file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol#L47-L57 hash=20f6aa15d113dcaf992875184173cb47
          ```

          Users call this function to transfer original tokens to the contract and mint themselves an equivalent number of lockbox tokens.
          This function has several tests to make sure it can be called.

          *   Check the chain ID.
              Locking and redeeming tokens can only be done on the original token's chain.
          *   Use [`transferFrom`](https://ethereum.org/en/developers/tutorials/erc20-annotated-code/#transferFrom) to transfer the tokens to ourselves.
              This call typically reverts when it fails, but it can also return `false`.
              In that case, we revert.
              There are two reasons it may fail.
              *   The user (in this case, the `LockboxSuperchainERC20` contract) does not have [the allowance](https://ethereum.org/en/developers/tutorials/erc20-annotated-code/#_approve) to spend that amount of tokens from the original owner (`msg.sender`).
              *   The original owner (`msg.sender`) does not have enough tokens to transfer.

          If the tests are successful, mint the requested amount for `msg.sender`.

          ```solidity file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol#L59-L67 hash=2e63a9cd1ac1114c3fb2110e28b60924
          ```

          Users call this function to redeem their existing lockbox tokens and replace them with the original tokens.
          It also has multiple tests.

          *   Again, check chain ID.
          *   Try to `_burn` the amount of lockbox tokens.
              [The solady `_burn` function](https://github.com/Vectorized/solady/blob/main/src/tokens/ERC20.sol#L539-L542), the one we inherit from `SuperchainERC20`, reverts if the user does not have enough tokens to burn.
          *   Transfer the amount of the original ERC-20 redeemed to
              the caller.
              This should never fail, because lockbox ERC-20 tokens are supposed to always be backed by an equal number of the original tokens.
              However, if it does fail for some reason, revert.
        </details>

  2.  Actually deploy the contract.

      ```sh
      pnpm contracts:deploy:token
      ```

  3.  Get the new token address and store it in an environment variable.

      ```sh
      NEW_TOKEN_ADDRESS=`cat packages/contracts/broadcast/multi/LockboxDeployer.s.sol-latest/run.json | awk '/contractAddress/ {print $2}' | head -1 | sed 's/[",]//g'`
      ```
</Steps>

<details>
  <summary>Sanity check</summary>

  1.  Check that the user has a single token of the original ERC-20 (or 0.9 if you did the proxy upgrade steps on the same token).

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      ```

  2.  Lock a quarter token in the lockbox ERC-20 contract.
      To do this we first need to give the lockbox ERC-20 contract an allowance and then call it.

      ```sh
      QUARTER_TOKEN=`echo 0.25 | cast to-wei`
      cast send $ERC20_ADDRESS "approve(address,uint256)" $NEW_TOKEN_ADDRESS $QUARTER_TOKEN --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_A
      cast send $NEW_TOKEN_ADDRESS "lockAndMint(uint256)" $QUARTER_TOKEN --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_A
      ```

  3.  See the balances of the user, both original and lockbox, and the balance of the lockbox contract itself.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $ERC20_ADDRESS "balanceOf(address)" $NEW_TOKEN_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      ```

  4.  Transfer 0.1 token to chain B.

      ```sh
      TENTH_TOKEN=`echo 0.1 | cast to-wei`
      cast send $INTEROP_BRIDGE --rpc-url $URL_CHAIN_A --private-key $PRIVATE_KEY "sendERC20(address,address,uint256,uint256)" $NEW_TOKEN_ADDRESS $USER_ADDRESS $TENTH_TOKEN 902
      ```

  5.  See the user's balances on both chains.

      ```sh
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_B | cast from-wei
      ```

  6.  Specify the configuration for another user.

      ```sh
      USER_ADDRESS_2=0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC
      PRIVATE_KEY_2=0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a
      ```

  7.  Transfer new tokens to the new user (on chain B) and see that they were actually transferred.

      ```sh
      cast send $NEW_TOKEN_ADDRESS "transfer(address,uint256)" $USER_ADDRESS_2 $TENTH_TOKEN --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_B
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_B | cast from-wei
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS_2 --rpc-url $URL_CHAIN_B | cast from-wei      
      ```

  8.  As the new user, transfer tokens back to chain A and redeem them.

      ```sh
      cast send $INTEROP_BRIDGE --rpc-url $URL_CHAIN_B --private-key $PRIVATE_KEY_2 "sendERC20(address,address,uint256,uint256)" $NEW_TOKEN_ADDRESS $USER_ADDRESS_2 $TENTH_TOKEN 901
      cast send $NEW_TOKEN_ADDRESS --rpc-url $URL_CHAIN_A --private-key $PRIVATE_KEY_2 "redeemAndBurn(uint256)" $TENTH_TOKEN
      ```

  9.  See that the second user does not have any more of the new tokens, but does have the original token.

      ```sh
      cast call $NEW_TOKEN_ADDRESS "balanceOf(address)" $USER_ADDRESS_2 --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS_2 --rpc-url $URL_CHAIN_A | cast from-wei      
      ```
</details>

## Next steps

*   Deploy a [SuperchainERC20](./deploy-superchain-erc20) to the Superchain
*   [Learn more about SuperchainERC20](../superchain-erc20)
*   Build a [revolutionary app](/app-developers/get-started) that uses multiple blockchains within the Superchain
