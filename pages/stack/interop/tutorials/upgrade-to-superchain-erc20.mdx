---
title: Upgrading ERC-20 tokens for interop support
lang: en-US
description: What to do if you already have an ERC-20 token, and now you need to support Interop.
---

import { Callout } from 'nextra/components'
import { Steps } from 'nextra/components'

<Callout>
  The SuperchainERC20 standard is ready for production deployments.
  Please note that the OP Stack interoperability upgrade, required for crosschain messaging, is currently still in active development.
</Callout>

# Upgrading ERC-20 tokens for interop support

## Overview

This guide explains how to upgrade an ERC20 to a [`SuperchainERC20`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SuperchainERC20.sol) that can then teleport across the Superchain interop cluster quickly and safely using the [`SuperchainTokenBridge`](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SuperchainTokenBridge.sol) contract. For more information on how it works, [see the explainer](/stack/interop/superchain-erc20).

<details>
  <summary>About this tutorial</summary>

  **What you'll learn**

  *   How do upgrade an ERC-20 token to enable Superchain interoperability under various conditions.

  **Prerequisite knowlege**

  *   You should already know how to [deploy SuperchainERC20 tokens with custom code](./custom-superchain-erc20).
</details>

<Callout type="warning">
  The code on the documentation site is sample code, *not* production code.
  This means that we ran it, and it works as advertised.
  However, it did not pass through the rigorous audit process that most Optimism code undergoes.
  You're welcome to use it, but if you need it for production purposes you should get it audited first.
</Callout>

{/* 

I put this warning here, when we don't have it on most pages, because this tutorial
has, IMHO, code that is a lot more likely to be used in production. It doesn't just
show what is possible, it does the exact job needed.

*/}

### What you'll do

*   Upgrade an existing ERC-20 that uses [the proxy pattern](https://docs.openzeppelin.com/upgrades-plugins/proxies) to comply with interop requirements (with the proper authority).
*   Create a "lockbox" SuperchainERC20 contract to permissionlessly enable interop.

## Setup

<Steps>
  ### Install and run Supersim

  [Follow these instructions](/app-developers/tutorials/supersim/getting-started/installation) to install and run Supersim.

  <Callout>
    Make sure to run Supersim with autorelay on.

    ```sh
    ./supersim --interop.authorelay true
    ```
  </Callout>

  ### Setup the ERC-20 token on chain A

  Download and run the setup script.

  ```sh
  curl  https://docs.optimism.io/tutorials/setup-for-erc20-upgrade.sh > setup-for-erc20-upgrade.sh
  chmod +x setup-for-erc20-upgrade.sh
  ./setup-for-erc20-upgrade.sh
  ```

  ### Store the addresses

  Execute the bottom two lines of the setup script output to store the ERC-20 address and the address of the beacon contract.

  ```sh
  BEACON_ADDRESS=0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
  export ERC20_ADDRESS=0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
  ```

  ### Specify environment variables

  Specify these variables, which will be useful later.

  ```sh
  PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
  USER_ADDRESS=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
  URL_CHAIN_A=http://127.0.0.1:9545
  URL_CHAIN_B=http://127.0.0.1:9546
  INTEROP_BRIDGE=0x4200000000000000000000000000000000000028
  ```
</Steps>

## Upgrade a proxied contract

There are several requirements for an ERC-20 to use Superchain interop:

*   The ERC-20 contract has to implement [ERC-7802](https://eips.ethereum.org/EIPS/eip-7802) and [ERC-165](https://eips.ethereum.org/EIPS/eip-165).
    We need to modify the ERC-20 implementation for this support, which is the reason this particular technique requires a proxied contract where we control the proxy.
*   The equivalent ERC-20 contracts need to be on the same address on the other chains.
*   The storage layout of the ERC-20 contract needs to be the same as the one of `SuperchainERC20`.

The exact method to get the same address depends on how the proxy contract was initially deployed.
In this case we can see it in the upgrade script.

We need to follow the same steps, from the same address, with the same nonce.
Luckily, we should be able to do it in this case.

<Steps>
  ### Create a Foundry project

  We create a [Foundry](https://book.getfoundry.sh/) project and import the [OpenZeppelin](https://www.openzeppelin.com/solidity-contracts) contracts, which were used for the original ERC-20 and proxy deployment.

  ```sh
  mkdir proxy-upgrade
  cd proxy-upgrade
  forge init
  forge install OpenZeppelin/openzeppelin-contracts
  forge install OpenZeppelin/openzeppelin-contracts-upgradeable
  forge install ethereum-optimism/interop-lib
  ```

  ### Create and run the deployment script

  1.  Create an `script/LabSetup.s.sol` file with this content:

      ```solidity file=<rootDir>/public/tutorials/setup-for-erc20-upgrade.sh#L17-L56 hash=8c54bec9989ae4e1734825d3828ae220 filename="script/LabSetup.s.sol"
      ```

      This is the same deployment script used for the original deployment on chain A.

  2.  Run this command to deploy the same contracts on chain B.

      ```sh
      forge script script/LabSetup.s.sol --rpc-url $URL_CHAIN_B --broadcast --private-key $PRIVATE_KEY --tc LabSetup
      ```

      Scroll up and see the Logs section of the output:

      ```
      == Logs ==
      Token address: 0x5FbDB2315678afecb367f032d93F642f64180aa3
      msg.sender: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
      UpgradeableBeacon: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512
      Proxy: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
      ```

      Verify that the proxy address is the same as `$ERC20_ADDRESS`, and that the beacon address is the same as `$BEACON_ADDRESS`.

        <details>
          <summary>What to do when the values are not the same</summary>

          This can happen when the nonce values of `0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266` on chain A and chain B are different.

          You can see the nonce values using these commands:

          ```sh
          cast nonce $USER_ADDRESS --rpc-url $URL_CHAIN_A
          cast nonce $USER_ADDRESS --rpc-url $URL_CHAIN_B
          ```

          The easiest solution is to send transactions to the chain with the lower nonce until the nonces are equal, and then deploy to both chains.

          ```sh
          forge script script/LabSetup.s.sol --rpc-url $URL_CHAIN_A --broadcast --private-key $PRIVATE_KEY --tc LabSetup
          forge script script/LabSetup.s.sol --rpc-url $URL_CHAIN_B --broadcast --private-key $PRIVATE_KEY --tc LabSetup
          ```

          If you do this, remember to update `$ERC20_ADDRESS` and `$BEACON_ADDRESS`.
        </details>

  <Callout>
    Note that if we couldn't redeploy on chain A (because the ERC-20 was already in use, not just a test system) and the nonce on chain B was already higher than what it had been on chain A when the proxy contract was deployed, it would have been impossible to create on chain B an ERC-20 account with the same address as the ERC-20 on chain A.

    There are two alternative solutions:

    *   [Lockboxes](#lockboxes-for-permissionless-interop), which require users to exchange their tokens for tokens that can go through interop.
    *   Writing your own bridge, which allows for ERC-20 tokens on different addresses to be exchanged through interop.
  </Callout>

  ### Deploy ERC-7802 contracts

  We need to replace the ERC-20 contracts with contracts that:

  *   Support [ERC-7802](https://eips.ethereum.org/EIPS/eip-7802) and [ERC-165](https://eips.ethereum.org/EIPS/eip-165).
  *   Have the same storage layout as the ERC-20 contracts they replace.

  <Callout>
    These contracts do *not* need to be deployed to the same address.
    The address that needs to be the same is not the address of the ERC-20 contract itself, but of the proxy.
  </Callout>

  1.  Create a file, `src/InteropToken.sol`:

      ```solidity file=<rootDir>/public/tutorials/InteropToken.sol hash=007791836635608fdeb9c70c1b368f25 filename="src/InteropToken.sol"
      ```

        <details>
          <summary>Detailed explanation</summary>

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L1-L5 hash=36b9b9d0fb1ff680dc0eaa1c48b7c56b
          ```

          Most of the code is identical to the original `MyToken`.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L6-L7 hash=f06f3bd72be73dbd754008da7dd00d48        
          ```

          These are the imports needed for ERC-7802 support.
          We need `IERC165` for documentation purposes, and `IERC7802` for the ERC-7802 events.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L9 hash=ca402292e7551621669ef1a59b85d7ce     
          ```

          We also implement [ERC-165](https://eips.ethereum.org/EIPS/eip-165), but we don't need to import anything from there.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L10-L14 hash=37e9b49f50a8b70971ce5d0112bd934e     
          ```

          This function is identical to the one in `MyToken`.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L16-L36 hash=448a7e21e094b3fd961f2b8ee15bc6c7     
          ```

          Standard [ERC-7802](https://eips.ethereum.org/EIPS/eip-7802) behavior.

          ```solidity file=<rootDir>/public/tutorials/InteropToken.sol#L38-L42 hash=abb2093e9681984f25afa6f9d8b237a3     
          ```

          Standard [ERC-165](https://eips.ethereum.org/EIPS/eip-165) behavior.
        </details>

        <Callout>
          Copying the original ERC-20 token code with minimal differences is one method to keep the storage layout identical.
          Alternatively, if you want to use a different contract, such as `SuperchainERC20`, you can modify the storage layout to match the old one using [the Solidity docs](https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html).
        </Callout>

  2.  Deploy this contract on both chains, and store the addresses (which may or may not be the same).

      ```sh
      ERC7802_A=`forge create InteropToken --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_A --broadcast | awk '/Deployed to:/ {print $3}'`
      ERC7802_B=`forge create InteropToken --private-key $PRIVATE_KEY --rpc-url $URL_CHAIN_B --broadcast | awk '/Deployed to:/ {print $3}'`
      ```

  ### Update proxies

  Notify the beacon contracts of the new implementation contracts.

  ```sh
  cast send $BEACON_ADDRESS --private-key $PRIVATE_KEY "upgradeTo(address)" $ERC7802_A --rpc-url $URL_CHAIN_A
  cast send $BEACON_ADDRESS --private-key $PRIVATE_KEY "upgradeTo(address)" $ERC7802_B --rpc-url $URL_CHAIN_B  
  ```
</Steps>

<details>
  <summary>Sanity check</summary>

  1.  See your balance on chain A.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      ```

  2.  See your balance on chain B.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_B | cast from-wei
      ```

  3.  Transfer 0.1 token.

      ```sh
      AMOUNT=`echo 0.1 | cast to-wei`
      cast send $INTEROP_BRIDGE --rpc-url $URL_CHAIN_A --private-key $PRIVATE_KEY "sendERC20(address,address,uint256,uint256)" $ERC20_ADDRESS $USER_ADDRESS $AMOUNT 902
      ```

  4.  See the new balances. The A chain should have 0.9 tokens, and the B chain should have 0.1 tokens.

      ```sh
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_A | cast from-wei
      cast call $ERC20_ADDRESS "balanceOf(address)" $USER_ADDRESS --rpc-url $URL_CHAIN_B | cast from-wei
      ```
</details>

## Lockboxes for permissionless interop

There are many cases in which the previous technique is not usable:

*   The original ERC-20 contract was not deployed behind a proxy, so there is no way to make it implement [ERC-7802](https://eips.ethereum.org/EIPS/eip-7802).
*   The original ERC-20 contract was a proxy, but it was deployed either directly or using the [`CREATE`](https://www.evm.codes/?fork=cancun#f0) opcode and that nonce value has already been used by that address on one of the chains you need to interoperate with.
*   The private key for the address that originally deployed the ERC-20 contract is not available. This could happen, for example, because the organization that deployed the ERC-20 contract does not wish to cooperate.

For those cases there is an alternative solution, the lockbox.
We create a separate ERC-20 contract, which we control.
Users can transfer the original ERC-20 to the new ERC-20 contract, and in return get an equal number of new tokens.
Those tokens, because we control them, are interoperable.
Eventually, the owner of new ERC-20 tokens (either the original depositor or somebody else) can redeem them back for the original tokens.

<Steps>
  ### Setup environment variables

  We need a few more environment variables to make token information available for the new deployment.

  ```sh
  export ERC20_ADDRESS
  export ERC20_CHAINID=`cast chain-id --rpc-url $URL_CHAIN_A`
  ORIGINAL_TOKEN_NAME=`cast call $ERC20_ADDRESS "name()" --rpc-url $URL_CHAIN_A | cast to-ascii`
  export NEW_TOKEN_NAME="$ORIGINAL_TOKEN_NAME Lockbox"
  ORIGINAL_TOKEN_SYMBOL=`cast call $ERC20_ADDRESS "symbol()" --rpc-url $URL_CHAIN_A | cast to-ascii`
  export NEW_TOKEN_SYMBOL="$ORIGINAL_TOKEN_SYMBOL-L"
  export TOKEN_DECIMALS=`cast call $ERC20_ADDRESS "decimals()" --rpc-url $URL_CHAIN_A | cast to-dec`
  ```

  ### Update the deployment utilities

  The next `SuperchainERC20` variant is called `LockboxSuperchainERC20`, and it requires different constructor parameters.
  To be able to deploy it, we need to modify some of the deployment utilities.

  1.  Replace `packages/contracts/package.json` with this code:

      ```json filename="packages/contracts/package.json"
      {
        "name": "@superchainerc20-starter/contracts",
        "main": "index.js",
        "scripts": {
          "deploy:dev": "env-cmd -f .env cross-env-shell 'wait-port http://:8420/ready && forge script scripts/Superc>    "deploy:token": "env-cmd -f .env cross-env-shell 'forge script scripts/LockboxDeployer.s.sol --broadcast -->    "update:rpcs": "cd ../.. && ./scripts/fetch-superchain-rpc-urls.sh",
          "install": "forge install",
          "build": "forge build",
          "test": "forge test",
          "init:env": "cp .env.example .env"
        },
        "dependencies": {
          "viem": "^2.21.37"
        }
      }      
      ```

  2.  Create a new file, `packages/contracts/scripts/LockboxDeployer.s.sol`:

      ```solidity filename="packages/contracts/scripts/LockboxDeployer.s.sol" file=<rootDir>/public/tutorials/LockboxDeployer.s.sol hash=534b543709be173d87508a53322d8c59
      ```

        <details>
          <summary>Explanation of the modified functions</summary>

          For the most part, this is the standard `SuperchainERC20Deployer.s.sol` that comes with the [SuperchainERC20 starter kit](./deploy-superchain-erc20).
          Some functions are modified, as explained below.

          ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L46-L52 hash=302d02c3895f109e5e64d265b0473e6a
          ```

          Get the majority of the configuration from the environment.
          Mostly of it is derived from the configuration of the original ERC-20 token.

          Note that there is no `owner` here.
          This `SuperchainERC20` contract does not need an owner, because minting and burning are handled by the users themselves (by locking and unlocking the original tokens).

          ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L54-L69 hash=c45855080dc554cece35ed87e2d68f68
          ```

          "Manually" calculate the address that [`CREATE2`](https://www.evm.codes/?fork=cancun#f5) will give us.\
          If there is already a contract there, we have a problem.
          Otherwise, deploy `LockboxSuperchainERC20`.

          ```solidity file=<rootDir>/public/tutorials/LockboxDeployer.s.sol#L80-L84 hash=5d1f71b16a6f02d52a79b1a9e7588f87
          ```

          I modified this salt function to include a timestamp (obtained using `vm.unixTime()` in the constructor).
          This is not necessary, but I consider it a developer experience improvement.
          During development you redeploy slightly modified code a lot of times.
          It is easier if you don't need to manually change the salt every time.

          <Callout type="warning">
            Remove this before deploying to production.
            Otherwise, as new blockchains join the Interop cluster, you may not be able to deploy your contract at the same address.
          </Callout>
        </details>

  3.  Create this file in `packages/contracts/src/LockboxSuperchainERC20.sol`:

      ```solidity filename="packages/contracts/src/LockboxSuperchainERC20.sol" file=<rootDir>/public/tutorials/LockboxSuperchainERC20.sol hash=7fd49a23ddf10481be66dde8b0b23ccb
      ```
</Steps>
